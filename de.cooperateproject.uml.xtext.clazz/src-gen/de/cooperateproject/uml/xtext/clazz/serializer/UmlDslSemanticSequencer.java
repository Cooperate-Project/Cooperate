/*
 * generated by Xtext
 */
package de.cooperateproject.uml.xtext.clazz.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import de.cooperateproject.uml.xtext.clazz.services.UmlDslGrammarAccess;
import de.cooperateproject.uml.xtext.clazz.umlDsl.Association;
import de.cooperateproject.uml.xtext.clazz.umlDsl.AssociationEnd;
import de.cooperateproject.uml.xtext.clazz.umlDsl.Attribute;
import de.cooperateproject.uml.xtext.clazz.umlDsl.ClassDef;
import de.cooperateproject.uml.xtext.clazz.umlDsl.ClassDiagram;
import de.cooperateproject.uml.xtext.clazz.umlDsl.ConnectorCardinalitiy;
import de.cooperateproject.uml.xtext.clazz.umlDsl.ConnectorLabel;
import de.cooperateproject.uml.xtext.clazz.umlDsl.DataType;
import de.cooperateproject.uml.xtext.clazz.umlDsl.Generalization;
import de.cooperateproject.uml.xtext.clazz.umlDsl.Inheritance;
import de.cooperateproject.uml.xtext.clazz.umlDsl.Methode;
import de.cooperateproject.uml.xtext.clazz.umlDsl.Name;
import de.cooperateproject.uml.xtext.clazz.umlDsl.UmlDslPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class UmlDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UmlDslGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == UmlDslPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case UmlDslPackage.ASSOCIATION:
				sequence_Association(context, (Association) semanticObject); 
				return; 
			case UmlDslPackage.ASSOCIATION_END:
				sequence_AssociationEnd(context, (AssociationEnd) semanticObject); 
				return; 
			case UmlDslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case UmlDslPackage.CLASS:
				sequence_Class(context, (de.cooperateproject.uml.xtext.clazz.umlDsl.Class) semanticObject); 
				return; 
			case UmlDslPackage.CLASS_DEF:
				sequence_ClassDef(context, (ClassDef) semanticObject); 
				return; 
			case UmlDslPackage.CLASS_DIAGRAM:
				sequence_ClassDiagram(context, (ClassDiagram) semanticObject); 
				return; 
			case UmlDslPackage.CONNECTOR_CARDINALITIY:
				sequence_ConnectorCardinalitiy(context, (ConnectorCardinalitiy) semanticObject); 
				return; 
			case UmlDslPackage.CONNECTOR_LABEL:
				sequence_ConnectorLabel(context, (ConnectorLabel) semanticObject); 
				return; 
			case UmlDslPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case UmlDslPackage.GENERALIZATION:
				sequence_Generalization(context, (Generalization) semanticObject); 
				return; 
			case UmlDslPackage.INHERITANCE:
				sequence_Inheritance(context, (Inheritance) semanticObject); 
				return; 
			case UmlDslPackage.METHODE:
				sequence_Methode(context, (Methode) semanticObject); 
				return; 
			case UmlDslPackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     type=[ClassName|ID]
	 */
	protected void sequence_AssociationEnd(EObject context, AssociationEnd semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmlDslPackage.Literals.ASSOCIATION_END__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmlDslPackage.Literals.ASSOCIATION_END__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssociationEndAccess().getTypeClassNameIDTerminalRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=AssociationEnd right=AssociationEnd cardinality=ConnectorCardinalitiy?)
	 */
	protected void sequence_Association(EObject context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=[Type|ID])
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmlDslPackage.Literals.MEMBER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmlDslPackage.Literals.MEMBER__NAME));
			if(transientValues.isValueTransient(semanticObject, UmlDslPackage.Literals.MEMBER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmlDslPackage.Literals.MEMBER__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getTypeTypeIDTerminalRuleCall_4_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (classes+=ClassName classes+=ClassName*)
	 */
	protected void sequence_ClassDef(EObject context, ClassDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=Element*)
	 */
	protected void sequence_ClassDiagram(EObject context, ClassDiagram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[ClassName|ID] inheritance=Inheritance? members+=Member*)
	 */
	protected void sequence_Class(EObject context, de.cooperateproject.uml.xtext.clazz.umlDsl.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=Cardinality? middle=Cardinality? right=ConnectorLabel?)
	 */
	protected void sequence_ConnectorCardinalitiy(EObject context, ConnectorCardinalitiy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ConnectorLabel(EObject context, ConnectorLabel semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmlDslPackage.Literals.CONNECTOR_LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmlDslPackage.Literals.CONNECTOR_LABEL__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConnectorLabelAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DataType(EObject context, DataType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmlDslPackage.Literals.DATA_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmlDslPackage.Literals.DATA_TYPE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDataTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=AssociationEnd right=AssociationEnd)
	 */
	protected void sequence_Generalization(EObject context, Generalization semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmlDslPackage.Literals.CONNECTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmlDslPackage.Literals.CONNECTOR__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmlDslPackage.Literals.CONNECTOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmlDslPackage.Literals.CONNECTOR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGeneralizationAccess().getLeftAssociationEndParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGeneralizationAccess().getRightAssociationEndParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=[ClassName|ID] | type=[ClassName|ID])
	 */
	protected void sequence_Inheritance(EObject context, Inheritance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (attributes+=Attribute attributes+=Attribute*)* type=[Type|ID]?)
	 */
	protected void sequence_Methode(EObject context, Methode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID | ((longname=STRING | longname=ID) name=ID))
	 */
	protected void sequence_Name(EObject context, Name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
