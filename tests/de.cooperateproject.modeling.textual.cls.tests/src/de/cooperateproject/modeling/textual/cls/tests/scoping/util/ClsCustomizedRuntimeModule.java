/*
 * generated by Xtext 2.12.0
 */
package de.cooperateproject.modeling.textual.cls.tests.scoping.util;

import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.Arrays;
import java.util.Collection;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.reflections.Reflections;
import org.reflections.scanners.SubTypesScanner;
import org.reflections.util.ClasspathHelper;
import org.reflections.util.ConfigurationBuilder;
import org.reflections.util.FilterBuilder;

import com.google.inject.Inject;
import com.google.inject.Injector;

import de.cooperateproject.modeling.textual.cls.derivedstate.calculator.AssociationMemberEndDummy;
import de.cooperateproject.modeling.textual.cls.derivedstate.initializer.XtextAssociationInitializer;
import de.cooperateproject.modeling.textual.cls.derivedstate.remover.XtextAssociationRemover;
import de.cooperateproject.modeling.textual.common.derivedstate.calculator.UMLReferencingElementCalculator;
import de.cooperateproject.modeling.textual.common.derivedstate.initializer.VisibilityHavingElementInitializer;
import de.cooperateproject.modeling.textual.common.derivedstate.remover.UMLReferencingElementRemover;
import de.cooperateproject.modeling.textual.xtext.runtime.derivedstate.initializer.Applicability;
import de.cooperateproject.modeling.textual.xtext.runtime.derivedstate.initializer.DerivedStateProcessorApplicability;
import de.cooperateproject.modeling.textual.xtext.runtime.derivedstate.initializer.IAtomicDerivedStateProcessor;
import de.cooperateproject.modeling.textual.xtext.runtime.derivedstate.initializer.IAtomicDerivedStateProcessorRegistry;

/**
 * Runtime module for cls diagrams that injects test mocks.
 * 
 * This module enables running the tests as JUnit tests rather than plugin tests.
 */
public class ClsCustomizedRuntimeModule extends AbstractClsCustomizedRuntimeModule {

    private static class DummyAtomicProcessorRegistry implements IAtomicDerivedStateProcessorRegistry {
        private static final Class<?>[] RELEVANT_CLASSES = { IAtomicDerivedStateProcessor.class,
                UMLReferencingElementCalculator.class, UMLReferencingElementRemover.class,
                VisibilityHavingElementInitializer.class, AssociationMemberEndDummy.class,
                XtextAssociationRemover.class, XtextAssociationInitializer.class };

        @SuppressWarnings("rawtypes")
        private static final Map<DerivedStateProcessorApplicability, Map<Class<?>, IAtomicDerivedStateProcessor>> PROCESSORS = getProcessors();

        @Inject
        public DummyAtomicProcessorRegistry(Injector injector) {
            PROCESSORS.values().stream().map(Map::values).flatMap(Collection::stream).distinct()
                    .forEach(injector::injectMembers);
        }

        @SuppressWarnings("rawtypes")
        private static Map<DerivedStateProcessorApplicability, Map<Class<?>, IAtomicDerivedStateProcessor>> getProcessors() {

            Map<DerivedStateProcessorApplicability, Map<Class<?>, IAtomicDerivedStateProcessor>> categories = new EnumMap<>(
                    DerivedStateProcessorApplicability.class);
            for (DerivedStateProcessorApplicability applicability : DerivedStateProcessorApplicability.values()) {
                categories.put(applicability, new HashMap<>());
            }

            List<Class<?>> packageProvidingClasses = Arrays.asList(RELEVANT_CLASSES);
            Collection<URL> urls = packageProvidingClasses.stream().map(grammarutil -> ClasspathHelper
                    .forPackage(grammarutil.getPackage().getName(), grammarutil.getClassLoader()))
                    .flatMap(Collection::stream).collect(Collectors.toSet());
            String[] packageNames = packageProvidingClasses.stream().map(Class::getPackage).map(Package::getName)
                    .collect(Collectors.toSet()).toArray(new String[0]);
            Reflections reflections = new Reflections(
                    new ConfigurationBuilder().setUrls(urls).setScanners(new SubTypesScanner(false))
                            .filterInputsBy(new FilterBuilder().includePackage(packageNames)));
            Set<Class<? extends IAtomicDerivedStateProcessor>> subTypes = reflections
                    .getSubTypesOf(IAtomicDerivedStateProcessor.class).stream().filter(c -> !c.isInterface()
                            && !Modifier.isAbstract(c.getModifiers()) && Modifier.isPublic(c.getModifiers()))
                    .collect(Collectors.toSet());

            for (Class<? extends IAtomicDerivedStateProcessor> type : subTypes) {
                IAtomicDerivedStateProcessor<?> instance;
                try {
                    instance = type.newInstance();
                } catch (InstantiationException | IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
                Applicability applicabilities = instance.getClass().getAnnotation(Applicability.class);
                for (DerivedStateProcessorApplicability applicability : applicabilities.applicabilities()) {
                    categories.get(applicability).put(instance.getType(), instance);
                }
            }

            return categories;
        }

        @Override
        @SuppressWarnings("unchecked")
        public <T extends EObject> Optional<IAtomicDerivedStateProcessor<T>> findInitializer(Class<T> type) {
            return Optional.ofNullable(
                    PROCESSORS.get(DerivedStateProcessorApplicability.INITIALIZATION).getOrDefault(type, null));
        }

        @Override
        @SuppressWarnings("unchecked")
        public <T extends EObject> Optional<IAtomicDerivedStateProcessor<T>> findCleaner(Class<T> type) {
            return Optional
                    .ofNullable(PROCESSORS.get(DerivedStateProcessorApplicability.CLEANING).getOrDefault(type, null));
        }

        @Override
        @SuppressWarnings("unchecked")
        public <T extends EObject> Optional<IAtomicDerivedStateProcessor<T>> findCalculator(Class<T> type) {
            return Optional.ofNullable(
                    PROCESSORS.get(DerivedStateProcessorApplicability.CALCULATION).getOrDefault(type, null));
        }

    }

    @Override
    public Class<? extends IAtomicDerivedStateProcessorRegistry> bindIAtomicDerivedStateProcessorRegistry() {
        return DummyAtomicProcessorRegistry.class;
    };

}
