/*
 * generated by Xtext 2.9.0
 */
package de.cooperateproject.modeling.textual.cls.tests

import static org.junit.Assert.assertEquals
import static org.junit.Assert.assertTrue
import static org.junit.Assert.assertNotNull
import static org.junit.Assert.assertNull

import com.google.inject.Inject
import de.cooperateproject.modeling.textual.cls.cls.ClassDiagram
import de.cooperateproject.modeling.textual.cls.cls.Class
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.junit4.util.ParseHelper
import org.junit.AfterClass

import org.junit.BeforeClass
import org.junit.Test
import org.junit.runner.RunWith
import org.eclipse.uml2.uml.resources.util.UMLResourcesUtil
import org.eclipse.emf.ecore.resource.ResourceSet
import de.cooperateproject.modeling.textual.cls.tests.util.ClsTestInjectorProvider
import de.cooperateproject.modeling.textual.cls.cls.Interface
import de.cooperateproject.modeling.textual.cls.cls.Attribute
import de.cooperateproject.modeling.textual.cls.cls.Visibility
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.uml2.uml.VisibilityKind
import org.eclipse.uml2.uml.Property
import de.cooperateproject.modeling.textual.cls.cls.Method
import de.cooperateproject.modeling.textual.cls.cls.Generalization
import de.cooperateproject.modeling.textual.cls.cls.Implementation
import de.cooperateproject.modeling.textual.cls.cls.Association
import de.cooperateproject.modeling.textual.cls.cls.CommentLink
import de.cooperateproject.modeling.textual.cls.cls.Cardinality
import de.cooperateproject.modeling.textual.cls.cls.Classifier
import de.cooperateproject.modeling.textual.cls.cls.Member

@RunWith(XtextRunner)
@InjectWith(ClsTestInjectorProvider.DefaultProvider)
class ClsParsingTest {
	@Inject extension ParseHelper<ClassDiagram>

	private static ResourceSet rs;

	@BeforeClass
	static def void setup() {
		rs = new ResourceSetImpl
		UMLResourcesUtil.init(rs);
	}

	@AfterClass
	static def void tearDown() {
		if (rs != null) {
			rs.resources.forEach[r|r.unload]
		}
		rs = null
	}

	@Test
	def void classDefTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")
			assertTrue(clsClass instanceof Class)

			val refClass = clsClass.referencedElement
			assertTrue(refClass instanceof org.eclipse.uml2.uml.Class)
			assertEquals("Alice", refClass.name)
		]
	}

	private def Class findAndCheckClass(Iterable<Classifier> classifiers, String expectedClassifier) {
		val clsClass = findAndCheckClassifier(classifiers, expectedClassifier)
		assertTrue(clsClass instanceof Class)
		return clsClass as Class
	}

	private def Interface findAndCheckInterface(Iterable<Classifier> classifiers, String expectedClassifier) {
		val clsInterface = findAndCheckClassifier(classifiers, expectedClassifier)
		assertTrue(clsInterface instanceof Interface)
		return clsInterface as Interface
	}

	private def Classifier findAndCheckClassifier(Iterable<Classifier> classifiers, String expectedClassifier) {
		val clsClass = classifiers.findFirst[x|x.name.equals(expectedClassifier)]
		assertNotNull(clsClass)
		return clsClass
	}

	@Test
	def void interfaceDefTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			interface IAlice {}
			@end-cls
		'''.parse(rs) => [
			val clsInterface = findAndCheckInterface(allTransitiveClassifiers.filter(Classifier), "IAlice")

			val refInterface = clsInterface.referencedElement
			assertTrue(refInterface instanceof org.eclipse.uml2.uml.Interface)
			assertEquals("IAlice", refInterface.name)
		]
	}

	@Test
	def void aliasTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class "Alias Alice" as AA {
			}
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alias Alice")
			assertEquals("AA", clsClass.alias)

			val refClass = clsClass.referencedElement
			assertTrue(refClass instanceof org.eclipse.uml2.uml.Class)
			assertEquals("Alias Alice", refClass.name)
			assertEquals("AA", refClass.nameExpression.name)
		]
	}

	@Test
	def void abstractClassWithoutMembersTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			abstract class AbstractAlice {
			}
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "AbstractAlice")
			assertTrue((clsClass as Class).abstract)

			val refClass = clsClass.referencedElement
			assertTrue(refClass instanceof org.eclipse.uml2.uml.Class)
			assertEquals("AbstractAlice", refClass.name)
			assertTrue((refClass as org.eclipse.uml2.uml.Class).abstract)
		]
	}

	@Test
	def void classWithAttributesTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice {
				name : string
				age : int
			}
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")

			val clsMembers = clsClass.members
			assertEquals(2, clsMembers.size)

			val nameMember = clsMembers.findFirst[x|x.name.equals("name")] as Attribute
			val ageMember = clsMembers.findFirst[x|x.name.equals("age")] as Attribute

			assertNotNull(nameMember)
			assertTrue(nameMember.type instanceof PrimitiveType)
			assertEquals("EString", nameMember.type.name)

			assertNotNull(ageMember)
			assertTrue(ageMember.type instanceof PrimitiveType)
			assertEquals("EInt", ageMember.type.name)
		]
	}

	@Test
	def void classWithMethodesTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice {
				getName() : string
				setName(name : string)
				calculateAge(date : int) : int
			}
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")

			val clsMembers = clsClass.members
			assertEquals(3, clsMembers.size)

			val getNameMember = clsMembers.findFirst[x|x.name.equals("getName")] as Method
			val setNameMember = clsMembers.findFirst[x|x.name.equals("setName")] as Method
			val calculateAgeMember = clsMembers.findFirst[x|x.name.equals("calculateAge")] as Method

			checkType(getNameMember, "EString")
			assertEquals(0, getNameMember.parameters.size)

			assertNotNull(setNameMember)
			val setNameMemberParameter = setNameMember.parameters
			assertNull(setNameMember.type)
			assertEquals(1, setNameMemberParameter.size)
			assertEquals("name", setNameMemberParameter.last.name)
			assertTrue(setNameMemberParameter.last.type instanceof PrimitiveType)
			assertEquals("EString", setNameMemberParameter.last.type.name)

			checkType(calculateAgeMember, "EInt")

			val calculateAgeMemberParameter = calculateAgeMember.parameters
			assertEquals(1, calculateAgeMemberParameter.size)
			assertEquals("date", calculateAgeMemberParameter.last.name)
			assertTrue(calculateAgeMemberParameter.last.type instanceof PrimitiveType)
			assertEquals("EInt", calculateAgeMemberParameter.last.type.name)
		]
	}

	@Test
	def void visibiliesTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice {
				+name : string
				-age : int
				#getName() : string
				#setName(name : string)
				~calculateAge(date : int) : int
			}
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")

			val clsMembers = clsClass.members
			assertEquals(5, clsMembers.size)

			val nameMember = clsMembers.findFirst[x|x.name.equals("name")] as Attribute
			val ageMember = clsMembers.findFirst[x|x.name.equals("age")] as Attribute

			val getNameMember = clsMembers.findFirst[x|x.name.equals("getName")] as Method
			val setNameMember = clsMembers.findFirst[x|x.name.equals("setName")] as Method
			val calculateAgeMember = clsMembers.findFirst[x|x.name.equals("calculateAge")] as Method

			checkVisibility(nameMember, Visibility.PUBLIC, VisibilityKind.PUBLIC_LITERAL)
			checkVisibility(ageMember, Visibility.PRIVATE, VisibilityKind.PRIVATE_LITERAL)
			checkVisibility(getNameMember, Visibility.PROTECTED, VisibilityKind.PROTECTED_LITERAL)
			checkVisibility(setNameMember, Visibility.PROTECTED, VisibilityKind.PROTECTED_LITERAL)
			checkVisibility(calculateAgeMember, Visibility.PACKAGE, VisibilityKind.PACKAGE_LITERAL)
		]
	}

	private def void checkVisibility(Member member, Visibility visibility, VisibilityKind kind) {
		assertNotNull(member)
		assertEquals(visibility, member.visibility)
		assertEquals(kind, member.referencedElement.visibility)
	}

	@Test
	def void classWithStaticAndFinalAttributesTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice {
				name : string
				static age : int
				final ALICE_ID : string
				
				static getName() : string
				setName(name : string)
				abstract calculateAge(date : int) : int
			}
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")

			val clsMembers = clsClass.members
			assertEquals(6, clsMembers.size)

			val nameMember = clsMembers.findFirst[x|x.name.equals("name")] as Attribute
			val ageMember = clsMembers.findFirst[x|x.name.equals("age")] as Attribute
			val idMember = clsMembers.findFirst[x|x.name.equals("ALICE_ID")] as Attribute

			val getNameMember = clsMembers.findFirst[x|x.name.equals("getName")] as Method
			val setNameMember = clsMembers.findFirst[x|x.name.equals("setName")] as Method
			val calculateAgeMember = clsMembers.findFirst[x|x.name.equals("calculateAge")] as Method

			checkPropertyQualifier(nameMember, false, false)
			checkPropertyQualifier(ageMember, true, false)
			checkPropertyQualifier(idMember, false, true)
			checkOperationQualifier(getNameMember, true, false, false)
			checkOperationQualifier(setNameMember, false, false, false)
			checkOperationQualifier(calculateAgeMember, false, false, true)
		]
	}

	private def void checkPropertyQualifier(Attribute member, boolean isStatic, boolean isFinal) {
		assertNotNull(member)
		assertEquals(isStatic, member.isStatic)
		assertEquals(isFinal, member.isFinal)
		assertEquals(isStatic, member.referencedElement.isStatic)
	// TODO UML final
	}

	private def void checkOperationQualifier(Method member, boolean isStatic, boolean isFinal, boolean isAbstract) {
		assertNotNull(member)
		assertEquals(isStatic, member.isStatic)
		assertEquals(isFinal, member.isFinal)
		assertEquals(isAbstract, member.isAbstract)
		assertEquals(isStatic, member.referencedElement.isStatic)
		assertEquals(isAbstract, member.referencedElement.isAbstract)
	// TODO UML final
	}

	@Test
	def void datatypeTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class AliceAllTypes {
				stringMember : string
				intMember : int 
				doubleMember : double
				booleanMember : boolean
				charMember : char
				byteMember : byte
				shortMember : short
				longMember : long
				floatMember : float
			}
			@end-cls
		'''.parse(rs) => [
			val clsClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "AliceAllTypes")

			val clsMembers = clsClass.members
			assertEquals(9, clsMembers.size)

			val stringMember = clsMembers.findFirst[x|x.name.equals("stringMember")] as Attribute
			val intMember = clsMembers.findFirst[x|x.name.equals("intMember")] as Attribute
			val doubleMember = clsMembers.findFirst[x|x.name.equals("doubleMember")] as Attribute
			val booleanMember = clsMembers.findFirst[x|x.name.equals("booleanMember")] as Attribute
			val charMember = clsMembers.findFirst[x|x.name.equals("charMember")] as Attribute
			val byteMember = clsMembers.findFirst[x|x.name.equals("byteMember")] as Attribute
			val shortMember = clsMembers.findFirst[x|x.name.equals("shortMember")] as Attribute
			val longMember = clsMembers.findFirst[x|x.name.equals("longMember")] as Attribute
			val floatMember = clsMembers.findFirst[x|x.name.equals("floatMember")] as Attribute

			checkType(stringMember, "EString")
			checkType(intMember, "EInt")
			checkType(doubleMember, "EDouble")
			checkType(booleanMember, "EBoolean")
			checkType(charMember, "EChar")
			checkType(byteMember, "EByte")
			checkType(shortMember, "EShort")
			checkType(longMember, "ELong")
			checkType(floatMember, "EFloat")

		]
	}

	private def void checkType(Member member, String expected) {
		assertNotNull(member)
		assertTrue(member.type instanceof PrimitiveType)
		assertEquals(expected, member.type.name)
	}

	@Test
	def void classTypeTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice
			class Bob {
				alice : Alice
			}
			@end-cls
		'''.parse(rs) => [
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")
			val bobClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Bob")

			val bobMembers = bobClass.members
			assertEquals(1, bobMembers.size)
			val bobsMember = bobMembers.findFirst[x|x.name.equals("alice")] as Attribute

			assertNotNull(bobsMember)
			assertTrue(bobsMember.type instanceof org.eclipse.uml2.uml.Class)
			assertEquals("Alice", (bobsMember.type as org.eclipse.uml2.uml.Class).name)
		]
	}

	@Test
	def void classGeneralizationTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice
			class Bob
			asc Bob isa Alice
			@end-cls
		'''.parse(rs) => [
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Bob")
			val generalization = allTransitiveConnectors.findFirst[x|x instanceof Generalization] as Generalization

			assertNotNull(generalization)

			checkConnectorEnds(generalization, "Bob", "Alice")

			assertEquals("Alice", generalization.referencedElement.general.name)

		]
	}

	@Test
	def void classImplementationTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Bob
			interface IBob
			asc Bob impl IBob
			@end-cls
		'''.parse(rs) => [
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Bob")
			findAndCheckInterface(allTransitiveClassifiers.filter(Classifier), "IBob")
			val interface = allTransitiveConnectors.findFirst[x|x instanceof Implementation] as Implementation

			assertNotNull(interface)

			checkConnectorEnds(interface, "Bob", "IBob")

			assertEquals("IBob", interface.referencedElement.contract.name)

		]

	}

	@Test
	def void simpleClassAssociationTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice
			class Bob
			asc Alice association Bob
			@end-cls
		'''.parse(rs) => [
			val aliceClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Bob")
			val associations = allTransitiveConnectors.filter(Association)

			assertEquals(1, associations.size)
			val association = associations.last

			assertNotNull(association)

			checkConnectorEnds(association, "Alice", "Bob")

			var aliceAscEnd = association.referencedElement.ownedEnds.findFirst[x|x.type.name.equals("Alice")]
			assertNotNull(aliceAscEnd)

			var aliceProperties = aliceClass.referencedElement.members.filter(Property)
			var bobAscEnd = aliceProperties.findFirst [ x |
				x.association != null && x.type instanceof org.eclipse.uml2.uml.Class
			]
			assertEquals("Bob", bobAscEnd.type.name)
		]
	}

	private def dispatch void checkConnectorEnds(Association association, String expectedLeft, String expectedRight) {
		assertEquals(expectedLeft, association.left.name)
		assertEquals(expectedRight, association.right.name)
	}

	private def dispatch void checkConnectorEnds(Implementation implementation, String expectedLeft,
		String expectedRight) {
		assertEquals(expectedLeft, implementation.left.name)
		assertEquals(expectedRight, implementation.right.name)
	}

	private def dispatch void checkConnectorEnds(Generalization generalization, String expectedLeft,
		String expectedRight) {
		assertEquals(expectedLeft, generalization.left.name)
		assertEquals(expectedRight, generalization.right.name)
	}

	@Test
	def void classWithNoteTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice
			Alice note "this is a note"
			@end-cls
		'''.parse(rs) => [
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")
			val comment = allTransitiveConnectors.findFirst[x|x instanceof CommentLink] as CommentLink

			assertNotNull(comment)

			assertEquals("Alice", comment.left.name)
			assertEquals("this is a note", comment.comment.body)
		]

	}

	@Test
	def void ClassAsscociationWithNoteTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class Alice
			class Bob
			asc Alice association Bob note "this is another note"
			@end-cls
		'''.parse(rs) => [
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Alice")
			findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "Bob")
			val association = allTransitiveConnectors.findFirst[x|x instanceof Association] as Association

			assertNotNull(association)

			checkConnectorEnds(association, "Alice", "Bob")

			assertEquals("this is another note", association.comment.body)
		]
	}

	@Test
	def void CardinalityTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class AliceAsc 
			class BobAsc
			asc AliceAsc card0 BobAsc [*]
			asc AliceAsc card1 BobAsc [42|1..*]
			asc AliceAsc card2 BobAsc [*|24..42]
			asc AliceAsc card3 BobAsc [24..42|*]
			asc AliceAsc card4 BobAsc [*|*]
			@end-cls
		'''.parse(rs) =>
			[
				val aliceClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "AliceAsc")
				findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "BobAsc")
				val associations = allTransitiveConnectors.filter(Association)

				assertEquals(5, associations.size)

				val asc0 = associations.findFirst[x|x.referencedElement.name.equals("card0")]
				val asc1 = associations.findFirst[x|x.referencedElement.name.equals("card1")]
				val asc2 = associations.findFirst[x|x.referencedElement.name.equals("card2")]
				val asc3 = associations.findFirst[x|x.referencedElement.name.equals("card3")]
				val asc4 = associations.findFirst[x|x.referencedElement.name.equals("card4")]

				assertNotNull(asc0)
				assertNotNull(asc1)
				assertNotNull(asc2)
				assertNotNull(asc3)
				assertNotNull(asc4)

				checkConnectorEnds(asc0, "AliceAsc", "BobAsc")
				checkConnectorEnds(asc1, "AliceAsc", "BobAsc")
				checkConnectorEnds(asc2, "AliceAsc", "BobAsc")
				checkConnectorEnds(asc3, "AliceAsc", "BobAsc")
				checkConnectorEnds(asc4, "AliceAsc", "BobAsc")

				// Check UML and cls cardinalities
				val aliceClassMembers = aliceClass.referencedElement.members.filter(Property)
				// card0 [*]
				checkClsCardinality(asc0.properties.cardinalityLeft, asc0.properties.cardinalityRight, -1, 0, 0, 0)
				checkUMLCardinality(aliceClassMembers, asc0.referencedElement.members.filter(Property), "AliceAsc",
					"BobAsc", 0, -1, 0, -1)

				// card1 [42|1..*]
				checkClsCardinality(asc1.properties.cardinalityLeft, asc1.properties.cardinalityRight, 42, 0, 1, -1)
				checkUMLCardinality(aliceClassMembers, asc1.referencedElement.members.filter(Property), "AliceAsc",
					"BobAsc", 42, 42, 1, -1)
				// card2 [*|24..42]
				checkClsCardinality(asc2.properties.cardinalityLeft, asc2.properties.cardinalityRight, -1, 0, 24, 42)
				checkUMLCardinality(aliceClassMembers, asc2.referencedElement.members.filter(Property), "AliceAsc",
					"BobAsc", 0, -1, 24, 42)
				// card3 [24..42|*]
				checkClsCardinality(asc3.properties.cardinalityLeft, asc3.properties.cardinalityRight, 24, 42, -1, 0)
				checkUMLCardinality(aliceClassMembers, asc3.referencedElement.members.filter(Property), "AliceAsc",
					"BobAsc", 24, 42, 0, -1)
				// card4 [*|*]
				checkClsCardinality(asc4.properties.cardinalityLeft, asc4.properties.cardinalityRight, -1, 0, -1, 0)
				checkUMLCardinality(aliceClassMembers, asc4.referencedElement.members.filter(Property), "AliceAsc",
					"BobAsc", 0, -1, 0, -1)

			]
	}

	private def void checkClsCardinality(Cardinality left, Cardinality right, int leftLower, int leftUpper,
		int rightLower, int rightUpper) {
		checkClsCardinality(left, leftLower, leftUpper)
		if (right != null) {
			checkClsCardinality(right, rightLower, rightUpper)
		}
	}

	private def void checkClsCardinality(Cardinality cardinality, int lower, int upper) {
		assertEquals(lower, cardinality.lowerBound)
		assertEquals(upper, cardinality.upperBound)
	}

	private def void checkUMLCardinality(Iterable<Property> leftProperties, Iterable<Property> rightroperties,
		String ascLeftName, String ascRightName, int leftLower, int leftUpper, int rightLower, int rightUpper) {

		var leftAscEnd = rightroperties.findFirst[x|x.type.name.equals(ascLeftName)]
		assertNotNull(leftAscEnd)
		assertEquals(leftUpper, leftAscEnd.upper)
		assertEquals(leftLower, leftAscEnd.lower)

		var rightAscEnd = leftProperties.findFirst [ x |
			/*x.association == asc &&*/ x.type.name.equals(ascRightName) && x.upper == rightUpper &&
				x.lower == rightLower
		]
		assertNotNull(rightAscEnd)
	}

	@Test
	def void bidirectionTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class AliceBi
			class BobBi
			bi asc AliceBi bidirection BobBi
			bi asc AliceBi bidirectionCard BobBi [24|42]
			@end-cls
		'''.parse(rs) =>
			[
				val aliceClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "AliceBi")
				val bobClass = findAndCheckClass(allTransitiveClassifiers.filter(Classifier), "BobBi")
				val associations = allTransitiveConnectors.filter(Association)

				assertEquals(2, associations.size)
				val association = associations.findFirst[x|x.name.equals("bidirection")]
				val associationCard = associations.findFirst[x|x.name.equals("bidirectionCard")]

				assertNotNull(association)
				assertNotNull(associationCard)

				checkConnectorEnds(association, "AliceBi", "BobBi")
				assertTrue(association.isBidirectional)

				checkConnectorEnds(associationCard, "AliceBi", "BobBi")
				assertTrue(associationCard.isBidirectional)

				// check if association is bidirectional in uml
				bidirectionalCardinalityTest(aliceClass.referencedElement.members.filter(Property),
					bobClass.referencedElement.members.filter(Property), "AliceBi", "BobBi", association, 0, -1, 0, -1)

				checkClsCardinality(associationCard.properties.cardinalityLeft,
					associationCard.properties.cardinalityRight, 24, 0, 42, 0)

				bidirectionalCardinalityTest(aliceClass.referencedElement.members.filter(Property),
					bobClass.referencedElement.members.filter(Property), "AliceBi", "BobBi", associationCard, 24, 24,
					42, 42)

			]
	}

	private def void bidirectionalCardinalityTest(Iterable<Property> leftProperties, Iterable<Property> rightroperties,
		String ascLeftName, String ascRightName, Association association, int leftLower, int leftUpper, int rightLower,
		int rightUpper) {

		val leftPropertiesFiltered = leftProperties.filter[x|x.association == association.referencedElement]
		val rightPropertiesFiltered = rightroperties.filter[x|x.association == association.referencedElement]

		checkUMLCardinality(leftPropertiesFiltered, rightPropertiesFiltered, ascLeftName, ascRightName, leftLower,
			leftUpper, rightLower, rightUpper)
	}

	def void aggregationTest() {
		'''
			@start-cls "SomeName"
			rootPackage RootElement
			class AliceAgr
			class BobAgr
			asc AliceAgr association BobAgr
			agg AliceAgr aggregation BobAgr
			com AliceAgr composition BobAgr
			@end-cls
		'''.parse(rs) => []
	}

/* @Test @Ignore
 * def classAssociationDirectionTest() {
 * 	val model = '''
 * 		@startclass
 * 		class Alice {}
 * 		class Bob {}
 * 		Alice - Bob [24|42|labelID <]
 * 		Alice - Bob [42|24|labelID >]
 * 		@endclass
 * 	'''.parse
 * 	val xmiModel = getDiagram(TEST_FOLDER + "classAssociationDirection.xmi")

 * 	assertEqualsModel(model, xmiModel)
 * }
 */
}
