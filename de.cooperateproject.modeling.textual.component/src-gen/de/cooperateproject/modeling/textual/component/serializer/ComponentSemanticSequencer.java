/*
 * generated by Xtext 2.11.0
 */
package de.cooperateproject.modeling.textual.component.serializer;

import com.google.inject.Inject;
import de.cooperateproject.modeling.textual.common.metamodel.textualCommons.Comment;
import de.cooperateproject.modeling.textual.common.metamodel.textualCommons.TextualCommonsPackage;
import de.cooperateproject.modeling.textual.component.metamodel.component.Abstraction;
import de.cooperateproject.modeling.textual.component.metamodel.component.Attribute;
import de.cooperateproject.modeling.textual.component.metamodel.component.Component;
import de.cooperateproject.modeling.textual.component.metamodel.component.ComponentDiagram;
import de.cooperateproject.modeling.textual.component.metamodel.component.ComponentPackage;
import de.cooperateproject.modeling.textual.component.metamodel.component.Connector;
import de.cooperateproject.modeling.textual.component.metamodel.component.Dependency;
import de.cooperateproject.modeling.textual.component.metamodel.component.Generalization;
import de.cooperateproject.modeling.textual.component.metamodel.component.Interface;
import de.cooperateproject.modeling.textual.component.metamodel.component.Manifestation;
import de.cooperateproject.modeling.textual.component.metamodel.component.Method;
import de.cooperateproject.modeling.textual.component.metamodel.component.Provide;
import de.cooperateproject.modeling.textual.component.metamodel.component.Require;
import de.cooperateproject.modeling.textual.component.metamodel.component.RootPackage;
import de.cooperateproject.modeling.textual.component.metamodel.component.Substitution;
import de.cooperateproject.modeling.textual.component.services.ComponentGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ComponentSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ComponentGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ComponentPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ComponentPackage.ABSTRACTION:
				sequence_Abstraction(context, (Abstraction) semanticObject); 
				return; 
			case ComponentPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ComponentPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case ComponentPackage.COMPONENT_DIAGRAM:
				sequence_ComponentDiagram(context, (ComponentDiagram) semanticObject); 
				return; 
			case ComponentPackage.CONNECTOR:
				sequence_Connector(context, (Connector) semanticObject); 
				return; 
			case ComponentPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case ComponentPackage.GENERALIZATION:
				sequence_Generalization(context, (Generalization) semanticObject); 
				return; 
			case ComponentPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case ComponentPackage.MANIFESTATION:
				sequence_Manifestation(context, (Manifestation) semanticObject); 
				return; 
			case ComponentPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case ComponentPackage.PARAMETER:
				sequence_Parameter(context, (de.cooperateproject.modeling.textual.component.metamodel.component.Parameter) semanticObject); 
				return; 
			case ComponentPackage.PROVIDE:
				sequence_Provide(context, (Provide) semanticObject); 
				return; 
			case ComponentPackage.REQUIRE:
				sequence_Require(context, (Require) semanticObject); 
				return; 
			case ComponentPackage.ROOT_PACKAGE:
				sequence_RootPackage(context, (RootPackage) semanticObject); 
				return; 
			case ComponentPackage.SUBSTITUTION:
				sequence_Substitution(context, (Substitution) semanticObject); 
				return; 
			}
		else if (epackage == TextualCommonsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TextualCommonsPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ElementRelation returns Abstraction
	 *     Abstraction returns Abstraction
	 *
	 * Constraint:
	 *     (component+=[Component|EString] component+=[Component|EString]*)
	 */
	protected void sequence_Abstraction(ISerializationContext context, Abstraction semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (static?='static'? name=EString visibility=Visibility?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     body=EString
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TextualCommonsPackage.Literals.COMMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TextualCommonsPackage.Literals.COMMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getBodyEStringParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComponentDiagram returns ComponentDiagram
	 *
	 * Constraint:
	 *     (title=EString rootpackage=RootPackage)
	 */
	protected void sequence_ComponentDiagram(ISerializationContext context, ComponentDiagram semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ComponentPackage.Literals.COMPONENT_DIAGRAM__TITLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ComponentPackage.Literals.COMPONENT_DIAGRAM__TITLE));
			if (transientValues.isValueTransient((EObject) semanticObject, ComponentPackage.Literals.COMPONENT_DIAGRAM__ROOTPACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ComponentPackage.Literals.COMPONENT_DIAGRAM__ROOTPACKAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getComponentDiagramAccess().getTitleEStringParserRuleCall_3_0(), semanticObject.getTitle());
		feeder.accept(grammarAccess.getComponentDiagramAccess().getRootpackageRootPackageParserRuleCall_5_0(), semanticObject.getRootpackage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementContent returns Component
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         alias=EString? 
	 *         (comments+=Comment comments+=Comment*)? 
	 *         (component+=Component component+=Component*)? 
	 *         (port+=PortRelation port+=PortRelation*)? 
	 *         (interfacerelation+=InterfaceRelation interfacerelation+=InterfaceRelation*)? 
	 *         (interface+=Interface interface+=Interface*)?
	 *     )
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortRelation returns Connector
	 *     Connector returns Connector
	 *
	 * Constraint:
	 *     (port+=[Component|EString] port+=[Component|EString]* interface=[Interface|EString])
	 */
	protected void sequence_Connector(ISerializationContext context, Connector semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementRelation returns Dependency
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     (component+=[Component|EString] component+=[Component|EString]*)
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementRelation returns Generalization
	 *     Generalization returns Generalization
	 *
	 * Constraint:
	 *     (component+=[Component|EString] component+=[Component|EString]*)
	 */
	protected void sequence_Generalization(ISerializationContext context, Generalization semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementContent returns Interface
	 *     Interface returns Interface
	 *
	 * Constraint:
	 *     (name=EString alias=EString? (comments+=Comment comments+=Comment*)? (member+=Member member+=Member*)?)
	 */
	protected void sequence_Interface(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementRelation returns Manifestation
	 *     Manifestation returns Manifestation
	 *
	 * Constraint:
	 *     (component+=[Component|EString] component+=[Component|EString]*)
	 */
	protected void sequence_Manifestation(ISerializationContext context, Manifestation semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Method
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (static?='static'? abstract?='abstract'? name=EString visibility=Visibility? (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (static?='static'? name=EString visibility=Visibility?)
	 */
	protected void sequence_Parameter(ISerializationContext context, de.cooperateproject.modeling.textual.component.metamodel.component.Parameter semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceRelation returns Provide
	 *     Provide returns Provide
	 *
	 * Constraint:
	 *     interface=[Interface|EString]?
	 */
	protected void sequence_Provide(ISerializationContext context, Provide semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceRelation returns Require
	 *     Require returns Require
	 *
	 * Constraint:
	 *     interface=[Interface|EString]?
	 */
	protected void sequence_Require(ISerializationContext context, Require semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RootPackage returns RootPackage
	 *
	 * Constraint:
	 *     ((relation+=ElementRelation relation+=ElementRelation*)? (elementcontent+=ElementContent elementcontent+=ElementContent*)?)
	 */
	protected void sequence_RootPackage(ISerializationContext context, RootPackage semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementRelation returns Substitution
	 *     Substitution returns Substitution
	 *
	 * Constraint:
	 *     (component+=[Component|EString] component+=[Component|EString]*)
	 */
	protected void sequence_Substitution(ISerializationContext context, Substitution semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
}
