/*
 * generated by Xtext 
 */
package de.cooperateproject.modeling.textual.cls.ui.quickfix

import de.cooperateproject.modeling.textual.cls.cls.Attribute
import de.cooperateproject.modeling.textual.cls.cls.ClsFactory
import de.cooperateproject.modeling.textual.cls.cls.ClsPackage
import de.cooperateproject.modeling.textual.cls.cls.DataTypeReference
import de.cooperateproject.modeling.textual.cls.cls.Member
import de.cooperateproject.modeling.textual.cls.cls.Method
import de.cooperateproject.modeling.textual.cls.cls.Property
import de.cooperateproject.modeling.textual.cls.cls.UMLTypeReference
import de.cooperateproject.modeling.textual.cls.validation.ClsValidator
import de.cooperateproject.modeling.textual.cls.validation.TypeConverter
import java.util.Collection
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.Interface
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.uml2.uml.Operation
import org.eclipse.uml2.uml.Package
import org.eclipse.uml2.uml.Parameter
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.uml2.uml.Type
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import java.util.Collections
import org.eclipse.uml2.uml.UMLFactory
import de.cooperateproject.modeling.textual.cls.cls.AggregationKind
import org.eclipse.xtext.util.concurrent.IUnitOfWork
import org.eclipse.xtext.resource.XtextResource
import de.cooperateproject.modeling.textual.cls.cls.Classifier
import org.apache.log4j.Logger
import org.eclipse.uml2.uml.util.UMLUtil
import de.cooperateproject.modeling.textual.cls.cls.Commentable
import com.google.inject.Inject
import de.cooperateproject.modeling.textual.cls.services.ClsValueConverter

class ClsQuickfixProvider extends DefaultQuickfixProvider {

	static val LOGGER = Logger.getLogger(ClsQuickfixProvider)

	@Inject
	ClsValueConverter valueConverter

	/**
	 * Quickfix for missing Class in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_CLASS_REFERENCE)
	def createMissingUMLClass(Issue issue, IssueResolutionAcceptor acceptor) {
		val className = issue.data.get(0)
		acceptor.accept(issue, 'Create Class ' + className, 'Create the Class ' + className + ' in the UML Model', null) [ element, context |
			element.fixMissingClassifier(issue, context)
		]
	}
	
	
	/**
	 * Quickfix for missing Association in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_ASSOCIATION_REFERENCE)
	def createMissingUMLAssociation(Issue issue, IssueResolutionAcceptor acceptor) {
		val assoName = issue.data.get(0)
		acceptor.accept(issue, 'Create Association ' + assoName, 'Create the Association into the UML Diagram', null) [ element, context |
			element.fixMissingClassifier(issue, context)
		]
	}
	
	/**
	 * Quickfix for missing Generalization in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_GENERALIZATION_REFERENCE)
	def createMissingUMLGeneralization(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Create Generalization', 'Create the Generalization into the UML Diagram', null) [ element, context |
			element.fixCreateGeneralization()
			context.relinkState
		]
	}
	
	/**
	 * Quickfix for missing Generalization in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_REALIZATION_REFERENCE)
	def createMissingUMLRealizationn(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Create InterfaceRealization', 'Create the InterfaceRealization into the UML Diagram', null) [ element, context |
			element.fixCreateRealization()
			context.relinkState
		]
	}
	

	/**
	 * Quickfix for missing Interface in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_INTERFACE_REFERENCE)
	def createMissingUMLInterface(Issue issue, IssueResolutionAcceptor acceptor) {
		val interfaceName = issue.data.get(0)
		acceptor.accept(issue, 'Create Interface ' + interfaceName, 'Create the Interface into the UML Diagram', null) [ element, context |
			element.fixMissingClassifier(issue, context)
		]
	}
	
	/**
	 * Quickfix for missing Package in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_PACKAGE_REFERENCE)
	def createMissingUMLPackage(Issue issue, IssueResolutionAcceptor acceptor) {
		val packageName = issue.data.get(0)
		acceptor.accept(issue, 'Create Package ' + packageName, 'Create the Package into the UML Diagram', null) [ element, context |
			element.fixMissingClassifier(issue, context)
		]
	}
	
	/**
	 * Quickfix for missing PackageImport in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_IMPORT_REFERENCE)
	def createMissingUMLImport(Issue issue, IssueResolutionAcceptor acceptor) {
		val packageName = issue.data.get(0)
		acceptor.accept(issue, 'Create PackageImport ' + packageName, 'Create the PackageImport into the UML Diagram', null) [ element, context |
			element.fixMissingClassifier(issue, context)
		]
	}
	
	/**
	 * Quickfix for missing Property in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_PROPERTY_REFERENCE)
	def createMissingUMLProperty(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Create Property', 'Create the Property into the UML Diagram', null) [ element, context |
			element.fixMissingMember(issue, context)
		]
	}
	
	/**
	 * Quickfix for wrong Property type in the Cls-model.
	 */
	@Fix(ClsValidator::WRONG_PROPERTY_TYPE)
	def wrongPropertyType(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change Type', 'Change the property type into the right one', null) [ element, context |
			if (element instanceof Property) {
				element.fixWrongType(issue, context)
			}
		]
	}
	
	/**
	 * Quickfix for wrong Property type in the Cls-model.
	 */
	@Fix(ClsValidator::WRONG_PROPERTY_TYPE)
	def adjustModelPropertyType(Issue issue, IssueResolutionAcceptor acceptor) {
		val newType = issue.data.get(0)
		acceptor.accept(issue, "Adjust Type in model to '" + newType + "'", 'Change the property type in the model', null) [ element, context |
			if (element instanceof Property) {
				element.adjustModelType(issue, context)
			}
		]
	}
	
	/**
	 * Quickfix for Alias.
	 */
	@Fix(ClsValidator::NO_ALIAS_NAME)
	def createAliasExpression(Issue issue, IssueResolutionAcceptor acceptor) {
		val alias = issue.data.get(0)
		acceptor.accept(issue, "Define alias '" + alias + "' in model", 'Create the nameExpression in the model', null) [ element, context |
			if (element instanceof Classifier) {
				element.fixCreateNameExpression(issue, context)
			}
		]
	}
	
	@Fix(ClsValidator::WRONG_ALIAS_NAME)
	def changeAliasExpression(Issue issue, IssueResolutionAcceptor acceptor) {
		val alias = issue.data.get(0)
		acceptor.accept(issue, "Change alias to '" + alias + "' in model", 'Create the nameExpression in the model', null) [ element, context |
			if (element instanceof Classifier) {
				element.fixChangeNameExpression(issue, context)
			}
		]
	}
	
	/**
	 * Quickfix for missing Operation in the UML-diagram.
	 */
	@Fix(ClsValidator::NO_OPERATION_REFERENCE)
	def createMissingUMLOperation(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Create Operation', 'Create the Operation into the UML Diagram', null) [ element, context |
			if (element instanceof Method) {
				element.fixMissingMember(issue, context)
			}
		]
	}
	
	@Fix(ClsValidator::NO_COMMENT_REFERENCE)
	def createMissingUMLComment(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Create Comment', 'Create the Comment into the UML Diagram', null) [ element, context |
			if (element instanceof Commentable) {
				element.fixMissingComment(issue, context)
			}
		]
	}
	
	def void fixMissingComment(Commentable commentable, Issue issue, IModificationContext context) {
		var commentBody = context.xtextDocument.get(issue.offset, issue.length)
		commentBody = valueConverter.convertCommentBody.toValue(commentBody, NodeModelUtils.getNode(commentable))
		val commentedElement = commentable.commentedElement
		val umlComment = UMLFactory.eINSTANCE.createComment
		commentedElement.nearestPackage.ownedComments.add(umlComment)
		umlComment.annotatedElements.add(commentedElement)
		umlComment.body = commentBody
		umlComment.save
		commentable.comment = umlComment
	}
	
	private static def fixMissingClassifier(EObject element, Issue issue, IModificationContext context) {
		var name = context.xtextDocument.get(issue.offset, issue.length)
		val brokenElement = element as de.cooperateproject.modeling.textual.cls.cls.Element;
		val parentPackage = brokenElement.nearestPackage
		val umlPackage = parentPackage?.referencedElement
		if (umlPackage == null) {
			LOGGER.warn("Could not create classifier because of missing parent.")
			return
		}
		brokenElement.fixCreate(umlPackage, name)
	}
	
	private static def dispatch void fixCreate(de.cooperateproject.modeling.textual.cls.cls.Class brokenClassifier, Package parentPackage, String name) {
		val umlClass = parentPackage.createOwnedClass(name, brokenClassifier.abstract);
		parentPackage.save
		brokenClassifier.referencedElement = umlClass;
	}
	
	private static def dispatch void fixCreate(de.cooperateproject.modeling.textual.cls.cls.Package brokenClassifier, Package parentPackage, String name) {
		val umlPackage = parentPackage.createNestedPackage(name)
		parentPackage.save
		brokenClassifier.referencedElement = umlPackage;
	}
	
	private static def dispatch void fixCreate(de.cooperateproject.modeling.textual.cls.cls.PackageImport brokenClassifier, Package parentPackage, String name) {
		//TODO: What about FQN?
		val model = parentPackage.model
		//UMLUtil.findNamedElements
		
		val importedPackage = model.getNestedPackage(name)
		val umlImport = parentPackage.createPackageImport(importedPackage)
		parentPackage.save
		brokenClassifier.referencedElement = umlImport;
	}
	
	private static def dispatch void fixCreate(de.cooperateproject.modeling.textual.cls.cls.Interface brokenClassifier, Package parentPackage, String name) {
		val umlInterface = parentPackage.createOwnedInterface(name);
		parentPackage.save
		brokenClassifier.referencedElement = umlInterface;
	}
	
	private static def dispatch void fixCreate(de.cooperateproject.modeling.textual.cls.cls.Association brokenClassifier, Package parentPackage, String name) {

		val leftType = brokenClassifier.left.UMLType
		val rightType = brokenClassifier.right.UMLType
		val props = brokenClassifier.properties
		
		//val umlAssociation = UMLFactory.eINSTANCE.createAssociation;
		val umlAssociation = leftType.createAssociation(
			true,
			brokenClassifier.aggregationKind.UMLAggregationKind,
			leftType.name.toFirstLower,
			if(props!= null) props.cardinalityLeft.lowerBound else 0,
			if(props!= null) props.cardinalityLeft.upperBound else -1,
			rightType,
			brokenClassifier.bidirectional,
			AggregationKind.NONE.UMLAggregationKind,
			rightType.name.toFirstLower,
			if(props!= null) props.cardinalityRight.lowerBound else 0,
			if(props!= null) props.cardinalityRight.upperBound else -1
		)
		umlAssociation.name = name
		
		//TODO: Check where we want to put our Associations
		//parentPackage.packagedElements.add(umlAssociation);
		//val nodeRoot = brokenClassifier.eContainer as Package
		
		umlAssociation.package = parentPackage
		//val nearestPackage = umlAssociation.package
		
		parentPackage.save
		brokenClassifier.referencedElement = umlAssociation;
	}
	
	
	private static def void fixCreateGeneralization(EObject element) {
		val generalization = element as de.cooperateproject.modeling.textual.cls.cls.Generalization
		val left = generalization.left.type as org.eclipse.uml2.uml.Class
		val right = generalization.right.type as org.eclipse.uml2.uml.Class
		val umlGeneralization = left.createGeneralization(right)
		left.save
		//TODO: This is currently derived automatically
		//generalization.referencedElement = umlGeneralization;
	}
	
	private static def void fixCreateRealization(EObject element) {
		val implementation = element as de.cooperateproject.modeling.textual.cls.cls.Implementation
		val left = implementation.left.type as org.eclipse.uml2.uml.Class
		val right = implementation.right.type as Interface
		val umlInterfaceRealization = UMLFactory.eINSTANCE.createInterfaceRealization
		umlInterfaceRealization.contract = right
		umlInterfaceRealization.implementingClassifier = left
		left.save
		//implementation.eResource.modified = true
		//TODO: This is currently derived automatically
		//generalization.referencedElement = umlGeneralization;
	}
	
	private static def fixWrongType(Property<? extends NamedElement> property, Issue issue, IModificationContext context) {
		val umlElement = property.referencedElement
		val umlType = umlElement?.getType
		property.type = getClsType(umlType)
	}
	
	private static def adjustModelType(Property<? extends NamedElement> property, Issue issue, IModificationContext context) {
		val umlElement = property.referencedElement
		umlElement.type = property.type.UMLType
		umlElement.save
		relinkState(context)	
		
	}
	
	private static def fixCreateNameExpression(Classifier classifier, Issue issue, IModificationContext context) {
		val nameString = issue.data.get(0)
		val umlElement = classifier.referencedElement
		val expression = umlElement.createNameExpression(nameString, null)
		umlElement.save
		classifier.aliasExpression = expression
		
	}
	
	private static def fixChangeNameExpression(Classifier classifier, Issue issue, IModificationContext context) {
		val nameString = issue.data.get(0)
		val umlElement = classifier.referencedElement
		val expression = umlElement.nameExpression
		expression.name = nameString
		umlElement.save
		classifier.aliasExpression = expression
		
	}
	
	
	private static def dispatch Type getType(Operation umlOperation) {
		return umlOperation.type
	}
	
	private static def dispatch Type getType(org.eclipse.uml2.uml.Property umlAttribute) {
		return umlAttribute.type
	}
	
	private static def dispatch Type getType(Parameter umlParameter) {
		return umlParameter.type
	}
	
	private static def dispatch setType(Operation umlOperation, Type type) {
		umlOperation.type = type
	}
	
	private static def dispatch setType(org.eclipse.uml2.uml.Property umlAttribute, Type type) {
		umlAttribute.type = type
	}
	
	private static def dispatch setType(Parameter umlParameter, Type type) {
		umlParameter.type = type
	}
	

	private def fixMissingMember(EObject element, Issue issue, IModificationContext context) {
		val name = context.xtextDocument.get(issue.offset, issue.length)
		val brokenMember = element as Member<?>
		val classifier = brokenMember.owner
		val umlClassifier = classifier.referencedElement
		if (umlClassifier == null) {
			return
		}
		brokenMember.fixCreate(umlClassifier, name)
	}
		
	private static def dispatch void fixCreate(Attribute brokenAttribute, Class umlClassifier, String name) {
		val umlType = getUMLType(brokenAttribute.type)
		val umlAttribute = umlClassifier.createOwnedAttribute(name, umlType)
		umlClassifier.save
		brokenAttribute.referencedElement = umlAttribute
	}
	
	private static def dispatch void fixCreate(Attribute brokenAttribute, Interface umlClassifier, String name) {
		val umlType = getUMLType(brokenAttribute.type)
		val umlAttribute = umlClassifier.createOwnedAttribute(name, umlType)
		umlClassifier.save
		brokenAttribute.referencedElement = umlAttribute
	}
	
	
	private static def dispatch void fixCreate(Method brokenMethod, Class umlClassifier, String name) {
		brokenMethod.fixCreate[paramNames, paramTypes, returnType | 
			val umlOperation = umlClassifier.createOwnedOperation(name, paramNames, paramTypes, returnType)
			umlClassifier.save
			brokenMethod.referencedElement = umlOperation
		]
	}
	
	private static def dispatch void fixCreate(Method brokenMethod, Interface umlClassifier, String name) {
		brokenMethod.fixCreate[paramNames, paramTypes, returnType | 
			val umlOperation = umlClassifier.createOwnedOperation(name, paramNames, paramTypes, returnType)
			umlClassifier.save
			brokenMethod.referencedElement = umlOperation
		]
	}
	
	private interface MethodCreateFixer {
		def void fix(EList<String> parameterNames, EList<Type> parameterTypes, Type returnType)
	}
	
	private static def void fixCreate(Method brokenMethod, MethodCreateFixer fixer) {
		val parameterNames = brokenMethod.parameters.map[p | NodeModelUtils.findNodesForFeature(p, ClsPackage.Literals.UML_REFERENCING_ELEMENT__REFERENCED_ELEMENT).map[n | NodeModelUtils.getTokenText(n)].findFirst[true]]
		val parameterTypes = brokenMethod.parameters.map[p | p.type.getUMLType]
		val returnType = brokenMethod.type.getUMLType
		
		if (parameterNames.size != parameterTypes.size) {
			return
		}
		
		fixer.fix(parameterNames.encapsulate, parameterTypes.encapsulate, returnType)
	}
	
	private static def <T> EList<T> encapsulate(Collection<T> elements) {
		return new BasicEList<T>(elements)
	}
	
	private static def dispatch getClsType(PrimitiveType type) {
		val primitiveType = TypeConverter.getPrimitive(type)
		if (primitiveType == null) {
			return null
		}
		val dataTypeReference = ClsFactory.eINSTANCE.createDataTypeReference
		dataTypeReference.type = primitiveType
		return dataTypeReference
	}
	
	private static def dispatch getClsType(Type type) {
		if (type == null) {
			return null
		}
		val umlTypeReference = ClsFactory.eINSTANCE.createUMLTypeReference
		umlTypeReference.type = type
		return umlTypeReference
	}
	
	private static def dispatch getClsType(Void type) {
		return null
	}
	
	private static def getUMLAggregationKind(AggregationKind kind) {
		switch kind {
			case AGGREGATION :  org.eclipse.uml2.uml.AggregationKind.SHARED_LITERAL
			case COMPOSITION : org.eclipse.uml2.uml.AggregationKind.COMPOSITE_LITERAL
			case NONE : org.eclipse.uml2.uml.AggregationKind.NONE_LITERAL
		}
		
	}
	
	private static def dispatch getUMLType(DataTypeReference type) {
		return TypeConverter.getType(type.type, type.eResource.resourceSet)
	}
	
	private static def dispatch getUMLType(UMLTypeReference type) {
		return type.type
	}
	
	private static def dispatch getUMLType(Void type) {
		return null
	}
	
	private static def save (EObject o) {
		o.eResource.save(Collections.emptyMap)
	}

	private static def relinkState(IModificationContext context) {
		context.xtextDocument.modify(new IUnitOfWork.Void<XtextResource>() {
				
				override process(XtextResource state) throws Exception {
					state.relink
				}
			})
	}
}
