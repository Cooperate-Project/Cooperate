/*
 * generated by Xtext
 */
package de.cooperateproject.modeling.textual.cls.ui.labeling

import com.google.inject.Inject
import de.cooperateproject.modeling.textual.cls.cls.Association
import de.cooperateproject.modeling.textual.cls.cls.AssociationMemberEnd
import de.cooperateproject.modeling.textual.cls.cls.Attribute
import de.cooperateproject.modeling.textual.cls.cls.Class
import de.cooperateproject.modeling.textual.cls.cls.ClassDiagram
import de.cooperateproject.modeling.textual.cls.cls.Generalization
import de.cooperateproject.modeling.textual.cls.cls.Implementation
import de.cooperateproject.modeling.textual.cls.cls.Interface
import de.cooperateproject.modeling.textual.cls.cls.Method
import de.cooperateproject.modeling.textual.cls.cls.Package
import de.cooperateproject.modeling.textual.cls.cls.Parameter
import de.cooperateproject.modeling.textual.cls.cls.Property
import de.cooperateproject.modeling.textual.cls.cls.XtextAssociation
import de.cooperateproject.modeling.textual.cls.cls.XtextAssociationMemberEndReferencedType
import de.cooperateproject.modeling.textual.common.outline.CooperateOutlineLabelProvider
import de.cooperateproject.modeling.textual.common.outline.UMLImage
import java.util.Collection
import java.util.Optional
import java.util.function.Function
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider

/**
 * Provides labels for Cls Objects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
class ClsLabelProvider extends CooperateOutlineLabelProvider {

    @Inject
    new(AdapterFactoryLabelProvider delegate) {
        super(delegate)
    }

    def image(ClassDiagram ele) {
        return UMLImage.MODEL.image
    }

    def image(Class ele) {
        UMLImage.CLASS.image
    }

    def image(Interface ele) {
        UMLImage.INTERFACE.image
    }

    def image(Attribute ele) {
        UMLImage.PROPERTY.image.decorate(ele.visibility)
    }

    def image(Parameter ele) {
        UMLImage.PARAMETER.image.decorate(ele.visibility)
    }

    def image(Method ele) {
        UMLImage.OPERATION.image.decorate(ele.visibility)
    }

    def image(Association ele) {
        var img = UMLImage.ASSOCIATION.image
        if (ele.memberEnds.size == 2) {
            val aggregationKind = ele.memberEnds.get(0).aggregationKind
            img = switch aggregationKind {
                case COMPOSITION: UMLImage.ASSOCIATION_COMPOSITE.image
                case AGGREGATION: UMLImage.ASSOCIATION_SHARED.image
                default: img
            }
        }
        return img
    }
    
    def image(AssociationMemberEnd ele) {
        UMLImage.PROPERTY.image
    }

    def image(Generalization ele) {
        return UMLImage.GENERALIZATION.image
    }

    def image(Implementation ele) {
        return UMLImage.INTERFACE_REALIZATION.image
    }

    def image(Package pkg) {
        return UMLImage.PACKAGE.image
    }

    def image(XtextAssociationMemberEndReferencedType typeReference) {
        return UMLImage.PROPERTY
    }
    
    def text(Package ele) {
        "package " + ele.name
    }
    
    def text(Class ele) {
        if (ele.alias !== null) {
            return "class " + ele.alias
        }
        return "class " + ele.name
    }

    def text(Method ele) {
        var text = text(ele as Property)
        if (text.contains(":")) {
            text = text.replaceAll(":", "():")
        } else {
            text += "()"
        }
        return text
    }

    def text(Property ele) {
        val typeRef = ele.type
        var type = ""
        if (typeRef !== null) {
            type = ": " + typeRef.doGetText
        }
        ele.name + type
    }

    def text(Interface ele) {
        return "interface " + ele.name
    }
    
    def text(Association ele) {
        var out = "asc "
        if (ele.name === null) {
        	out += ele.memberEnds.map[e | Optional.ofNullable(e.name).orElse(e.type?.name)].join("(", ", ", ")", Function.identity)
        } else {
            out += ele.name
        }        
        return out
    }

    def text(AssociationMemberEnd ele) {
        return ele.name ?: ele.type.name
    }

    def text(Generalization ele) {
        val leftChild = ele.left;
        val rightChild = ele.right;
        "isa (" + leftChild.name + ", " + rightChild.name + ")"
    }

    def text(Implementation ele) {
        val leftChild = ele.left;
        val rightChild = ele.right;
        "impl (" + leftChild.name + ", " + rightChild.name + ")"
    }
    def text(XtextAssociationMemberEndReferencedType typeReference) {
        val association = typeReference.eContainer as XtextAssociation
        val index = association.memberEndTypes.indexOf(typeReference)
        val name = association.memberEndNames.tryGet(index)
        var typeName = "";
        if (association.memberEndTypes.tryGet(index)?.type?.alias !== null) {
            typeName = association.memberEndTypes.tryGet(index)?.type?.alias
        } else {
            typeName = association.memberEndTypes.tryGet(index)?.type?.name
        }
        
        val cardinality = association.memberEndCardinalities.tryGet(index)
        var txt = String.format("%s : %s", name ?: "unnamed", typeName)
        if (cardinality !== null) {
            txt += String.format(" [%s]", cardinality.getText)
        }
        return txt
    }

    private static def <T> T tryGet(Collection<T> collection, int i) {
        if (collection.size > i) {
            return collection.get(i)
        }
        return null
    }

}
