/*
 * generated by Xtext
 */
package de.cooperateproject.modeling.textual.cls.ui.labeling

import com.google.inject.Inject
import de.cooperateproject.modeling.textual.cls.cls.AggregationKind
import de.cooperateproject.modeling.textual.cls.cls.Association
import de.cooperateproject.modeling.textual.cls.cls.Attribute
import de.cooperateproject.modeling.textual.cls.cls.Class
import de.cooperateproject.modeling.textual.cls.cls.ClassDiagram
import de.cooperateproject.modeling.textual.cls.cls.CommentLink
import de.cooperateproject.modeling.textual.cls.cls.DataTypeReference
import de.cooperateproject.modeling.textual.cls.cls.Generalization
import de.cooperateproject.modeling.textual.cls.cls.Implementation
import de.cooperateproject.modeling.textual.cls.cls.Interface
import de.cooperateproject.modeling.textual.cls.cls.MemberEnd
import de.cooperateproject.modeling.textual.cls.cls.Method
import de.cooperateproject.modeling.textual.cls.cls.MultiAssociation
import de.cooperateproject.modeling.textual.cls.cls.NamedElement
import de.cooperateproject.modeling.textual.cls.cls.Package
import de.cooperateproject.modeling.textual.cls.cls.PackageImport
import de.cooperateproject.modeling.textual.cls.cls.Parameter
import de.cooperateproject.modeling.textual.cls.cls.Property
import de.cooperateproject.modeling.textual.cls.cls.TypeReference
import de.cooperateproject.modeling.textual.cls.cls.UMLTypeReference
import de.cooperateproject.modeling.textual.cls.cls.Visibility
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.jface.viewers.DecorationOverlayIcon
import org.eclipse.jface.viewers.IDecoration
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider
import org.eclipse.swt.graphics.Image

/**
 * Provides labels for EObjects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
class ClsLabelProvider extends DefaultEObjectLabelProvider {

	static val visibilityMap = #{Visibility.PUBLIC -> UMLImage.VISIBILITY_PUBLIC.image,
		Visibility.PRIVATE -> UMLImage.VISIBILITY_PRIVATE.image,
		Visibility.PROTECTED -> UMLImage.VISIBILITY_PROTECTED.image,
		Visibility.PACKAGE -> UMLImage.VISIBILITY_PACKAGE.image}

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate)
	}
	
	def image(ClassDiagram ele) {
		return UMLImage.MODEL.image
	}

	def text(Class ele) {
		var name = ele.name
		return name
	}

	def text(NamedElement ele) {
		ele.name
	}

	def text(PackageImport ele) {
		ele.referencedElement.importedPackage.name;
	}

	def image(PackageImport ele) {
		UMLImage.PACKAGE_IMPORT.image
	}

	def text(Method ele) {
		var text = text(ele as Property)
		if (text.contains(":")) {
			text = text.replaceAll(":", "():")
		} else {
			text += "()"
		}
		return text
	}

	def text(Property ele) {
		val typeRef = ele.type
		var type = ""
		if (typeRef != null) {
			type = ": " + text(typeRef)
		}
		ele.name + type
	}

	def image(Class ele) {
		UMLImage.CLASS.image
	}

	def image(Interface ele) {
		UMLImage.INTERFACE.image
	}

	def image(Attribute ele) {
		UMLImage.PROPERTY.image.decorate(ele.visibility)
	}

	def image(Parameter ele) {
		UMLImage.PARAMETER.image.decorate(ele.visibility)
	}

	def image(Method ele) {
		UMLImage.OPERATION.image.decorate(ele.visibility)
	}

	def text(TypeReference ele) {
		if (ele instanceof UMLTypeReference) {
			text(ele as UMLTypeReference)
		} else if (ele instanceof DataTypeReference) {
			text(ele as DataTypeReference)
		}
	}

	def text(UMLTypeReference ele) {
		var cont = ele.eContainer
		if (cont instanceof Association) {
			return getAssociationMemberText(ele) 
		}
		ele.type.name
	}
	
	def image(UMLTypeReference ele) {
		if (ele.type instanceof org.eclipse.uml2.uml.Class) {
			return UMLImage.CLASS.image
		} else if (ele.type instanceof org.eclipse.uml2.uml.Interface) {
			return UMLImage.INTERFACE.image
		}
	}

	def text(DataTypeReference ele) {
		ele.type.name()
	}

	def text(Association ele) {
		if (ele.getComment() != null) {
			return ele.referencedElement.name + " - Comment"
		}
		val leftChild = ele.left;
		val rightChild = ele.right;
		return leftChild.type.name + " " + ele.referencedElement.name + " " + rightChild.type.name
	}

	def image(Association ele) {
		if (ele.getComment() != null) {
			return UMLImage.COMMENT.image
		} else if (ele.aggregationKind == AggregationKind.COMPOSITION) {
			return UMLImage.ASSOCIATION_COMPOSITE.image
		} else if (ele.aggregationKind == AggregationKind.AGGREGATION) {
			return UMLImage.ASSOCIATION_SHARED.image
		} else {
			return UMLImage.ASSOCIATION.image
		}
	}
	
	def getAssociationMemberText(UMLTypeReference ele) {
		var asso = ele.eContainer as Association
			if (ele == asso.left) {
				if (asso.properties != null && asso.properties.propertyLeft != null) {
					return ele.type.name + " as " + asso.properties.propertyLeft.name
				}
			} else if (ele == asso.right) {
				if (asso.properties != null && asso.properties.propertyRight != null) {
					return ele.type.name + " as " + asso.properties.propertyRight.name
				}
			}
			return ele.type.name
	}
	
	def text(MultiAssociation ele) {
		return ele.referencedElement.name
	}

	def image(MultiAssociation ele) {
		return UMLImage.ASSOCIATION.image
	}
	
	def text(MemberEnd ele) {
		if (ele.name != null) {
			return ele.name
		}
		return ele.type.text
	}
	
	def image(MemberEnd ele) {
		UMLImage.PROPERTY.image
	}

	def text(Generalization ele) {
		val leftChild = ele.left;
		val rightChild = ele.right;
		leftChild.doGetText + " is a " + rightChild.doGetText
	}

	def image(Generalization ele) {
		return UMLImage.GENERALIZATION.image
	}

	def text(Implementation ele) {
		val leftChild = ele.left;
		val rightChild = ele.right;
		leftChild.doGetText + " implements " + rightChild.doGetText
	}

	def image(Implementation ele) {
		return UMLImage.INTERFACE_REALIZATION.image
	}
	
	def text(CommentLink ele) {
		val leftChild = ele.left;
		return leftChild.doGetText + " - Comment"
	}
	
	def image(CommentLink ele) {
		return UMLImage.COMMENT.image
	}
	
	def image(Package pkg) {
		return UMLImage.PACKAGE.image
	}
	
	private def decorate(Image img, Visibility visibility) {
		if (visibility == null) {
			return img
		}
		val visibilityImage = visibilityMap.get(visibility)
		val imgDescriptor = new DecorationOverlayIcon(img, convertToImageDescriptor(visibilityImage), IDecoration.BOTTOM_RIGHT)
		imgDescriptor.createImage
	}
}	