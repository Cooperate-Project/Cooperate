/*
 * generated by Xtext
 */
package de.cooperateproject.modeling.textual.cls.ui.labeling

import com.google.inject.Inject
import de.cooperateproject.modeling.textual.cls.cls.AggregationKind
import de.cooperateproject.modeling.textual.cls.cls.Association
import de.cooperateproject.modeling.textual.cls.cls.Attribute
import de.cooperateproject.modeling.textual.cls.cls.Class
import de.cooperateproject.modeling.textual.cls.cls.ClassDiagram
import de.cooperateproject.modeling.textual.cls.cls.CommentLink
import de.cooperateproject.modeling.textual.cls.cls.Generalization
import de.cooperateproject.modeling.textual.cls.cls.Implementation
import de.cooperateproject.modeling.textual.cls.cls.Interface
import de.cooperateproject.modeling.textual.cls.cls.MemberEnd
import de.cooperateproject.modeling.textual.cls.cls.Method
import de.cooperateproject.modeling.textual.cls.cls.MultiAssociation
import de.cooperateproject.modeling.textual.cls.cls.NamedElement
import de.cooperateproject.modeling.textual.cls.cls.Package
import de.cooperateproject.modeling.textual.cls.cls.PackageImport
import de.cooperateproject.modeling.textual.cls.cls.Parameter
import de.cooperateproject.modeling.textual.cls.cls.Property
import de.cooperateproject.modeling.textual.cls.cls.Visibility
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.jface.viewers.DecorationOverlayIcon
import org.eclipse.jface.viewers.IDecoration
import org.eclipse.swt.graphics.Image
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.uml2.uml.PrimitiveType

/**
 * Provides labels for EObjects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
class ClsLabelProvider extends DefaultEObjectLabelProvider {

	static val visibilityMap = #{Visibility.PUBLIC -> UMLImage.VISIBILITY_PUBLIC.image,
		Visibility.PRIVATE -> UMLImage.VISIBILITY_PRIVATE.image,
		Visibility.PROTECTED -> UMLImage.VISIBILITY_PROTECTED.image,
		Visibility.PACKAGE -> UMLImage.VISIBILITY_PACKAGE.image}

	@Inject
	IQualifiedNameProvider qualifiedNameProvider;

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate)
	}
	
	def image(ClassDiagram ele) {
		return UMLImage.MODEL.image
	}

	def text(Class ele) {
		var name = ele.name
		return name
	}

	def text(NamedElement ele) {
		ele.name
	}

	def text(PackageImport ele) {
		ele.referencedElement.importedPackage.name;
	}

	def image(PackageImport ele) {
		UMLImage.PACKAGE_IMPORT.image
	}

	def text(Method ele) {
		var text = text(ele as Property)
		if (text.contains(":")) {
			text = text.replaceAll(":", "():")
		} else {
			text += "()"
		}
		return text
	}

	def text(Property ele) {
		val typeRef = ele.type
		var type = ""
		if (typeRef != null) {
			type = ": " + typeRef.doGetText
		}
		ele.name + type
	}

	def image(Class ele) {
		UMLImage.CLASS.image
	}

	def image(Interface ele) {
		UMLImage.INTERFACE.image
	}

	def image(Attribute ele) {
		UMLImage.PROPERTY.image.decorate(ele.visibility)
	}

	def image(Parameter ele) {
		UMLImage.PARAMETER.image.decorate(ele.visibility)
	}

	def image(Method ele) {
		UMLImage.OPERATION.image.decorate(ele.visibility)
	}

	def text(Association ele) {
		if (ele.getComment() != null) {
			return ele.referencedElement.name + " - Comment"
		}
		val leftChild = ele.left;
		val rightChild = ele.right;
		return leftChild.name + " " + ele.referencedElement.name + " " + rightChild.name
	}

	def image(Association ele) {
		if (ele.getComment() != null) {
			return UMLImage.COMMENT.image
		} else if (ele.aggregationKind == AggregationKind.COMPOSITION) {
			return UMLImage.ASSOCIATION_COMPOSITE.image
		} else if (ele.aggregationKind == AggregationKind.AGGREGATION) {
			return UMLImage.ASSOCIATION_SHARED.image
		} else {
			return UMLImage.ASSOCIATION.image
		}
	}
	
	def text(MultiAssociation ele) {
		return ele.referencedElement.name
	}

	def image(MultiAssociation ele) {
		return UMLImage.ASSOCIATION.image
	}
	
	def text(MemberEnd ele) {
		if (ele.name != null) {
			return ele.name
		}
		return ele.referencedElement.name
	}
	
	def image(MemberEnd ele) {
		UMLImage.PROPERTY.image
	}

	def text(Generalization ele) {
		val leftChild = ele.left;
		val rightChild = ele.right;
		leftChild.doGetText + " is a " + rightChild.doGetText
	}

	def image(Generalization ele) {
		return UMLImage.GENERALIZATION.image
	}

	def text(Implementation ele) {
		val leftChild = ele.left;
		val rightChild = ele.right;
		leftChild.doGetText + " implements " + rightChild.doGetText
	}

	def image(Implementation ele) {
		return UMLImage.INTERFACE_REALIZATION.image
	}
	
	def text(CommentLink ele) {
		val leftChild = ele.left;
		return leftChild.doGetText + " - Comment"
	}
	
	def image(CommentLink ele) {
		return UMLImage.COMMENT.image
	}
	
	def image(Package pkg) {
		return UMLImage.PACKAGE.image
	}
	
	def text(PrimitiveType type) {
		return qualifiedNameProvider.getFullyQualifiedName(type).toString;
	}
	
	private def decorate(Image img, Visibility visibility) {
		if (visibility == null || visibility == Visibility.UNDEFINED) {
			return img
		}
		val visibilityImage = visibilityMap.get(visibility)
		val imgDescriptor = new DecorationOverlayIcon(img, convertToImageDescriptor(visibilityImage), IDecoration.BOTTOM_RIGHT)
		imgDescriptor.createImage
	}

}	