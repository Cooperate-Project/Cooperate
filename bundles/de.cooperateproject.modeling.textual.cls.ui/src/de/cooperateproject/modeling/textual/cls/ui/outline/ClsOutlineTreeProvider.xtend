/*
 * generated by Xtext
 */
package de.cooperateproject.modeling.textual.cls.ui.outline

import com.google.inject.Inject
import de.cooperateproject.modeling.textual.cls.cls.Attribute
import de.cooperateproject.modeling.textual.cls.cls.ClassDiagram
import de.cooperateproject.modeling.textual.cls.cls.Method
import de.cooperateproject.modeling.textual.cls.cls.Parameter
import de.cooperateproject.modeling.textual.cls.cls.TypedConnector
import de.cooperateproject.modeling.textual.cls.ui.labeling.UMLImageGetter
import org.eclipse.jdt.ui.ISharedImages
import org.eclipse.jdt.ui.JavaUI
import org.eclipse.swt.graphics.RGB
import org.eclipse.xtext.ui.IImageHelper
import org.eclipse.xtext.ui.editor.outline.IOutlineNode
import org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode
import org.eclipse.xtext.ui.editor.utils.TextStyle
import org.eclipse.swt.SWT
import org.eclipse.xtext.ui.label.StylerFactory
import org.eclipse.jface.viewers.StyledString
import de.cooperateproject.modeling.textual.cls.cls.CommentLink
import de.cooperateproject.modeling.textual.cls.cls.Association
import de.cooperateproject.modeling.textual.cls.cls.MemberEnd
import de.cooperateproject.modeling.textual.cls.cls.MultiAssociation

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#outline
 */
class ClsOutlineTreeProvider extends DefaultOutlineTreeProvider {

	@Inject
	private StylerFactory stylerFactory;
	
	val images = JavaUI.getSharedImages();

	def _createChildren(DocumentRootNode parentNode, ClassDiagram root) {
		createNode(parentNode, root.rootPackage);
	}
	
	dispatch def createNode(IOutlineNode parentNode, de.cooperateproject.modeling.textual.cls.cls.Package pkg) {
		val newParentNode = createEObjectNode(parentNode, pkg);
		val packageNode = new AbstractOutlineNode(newParentNode, UMLImageGetter.getUMLImage("Package.gif"), getStyledString("Packages", pkg.classifiers.size), false) {};
		val importNode = new AbstractOutlineNode(newParentNode, images.getImage(ISharedImages.IMG_OBJS_IMPCONT), getStyledString("Imports", pkg.packageImports.size), false) {};
		val classifierNode = new AbstractOutlineNode(newParentNode, images.getImage(ISharedImages.IMG_OBJS_CLASS), getStyledString("Classifiers", pkg.classifiers.size), false) {};
		
		for (onePackage : pkg.packages) {
			createNode(packageNode, onePackage)
		}
		
		for (oneImport : pkg.packageImports) {
			createNode(importNode, oneImport)
		}

		for (oneClassifier : pkg.classifiers) {
			createNode(classifierNode, oneClassifier);
		}

		val connectors = newArrayList();
		val comments = newArrayList();
		for (oneConnector : pkg.connectors) {
			if (oneConnector instanceof CommentLink) {
				comments.add(oneConnector)
			} else if (oneConnector instanceof Association && (oneConnector as Association).comment != null) {
				comments.add(oneConnector)
				connectors.add(oneConnector)
			} else {
				connectors.add(oneConnector)
			}
		}
		
		val connectorNode = new AbstractOutlineNode(newParentNode, UMLImageGetter.getUMLImage("Association.gif"), getStyledString("Connectors",connectors.size), false) {};
		val commentNode = new AbstractOutlineNode(newParentNode, UMLImageGetter.getUMLImage("Comment.gif"), getStyledString("Comments",comments.size), false) {};
		for (oneComment : comments) {
			createNode(commentNode, oneComment)
		}
		for (oneConnector : connectors) {
			if (oneConnector instanceof Association && (oneConnector as Association).comment != null) {
				(oneConnector as Association).comment = null
			}
			createNode(connectorNode, oneConnector)
		}
	}
	
	dispatch def createNode(IOutlineNode parent, TypedConnector typedCon) {
		val associationNode = createEObjectNode(parent, typedCon);
		val leftChild = typedCon.left;
		val rightChild = typedCon.right;
		createNode(associationNode, leftChild)
		createNode(associationNode, rightChild)
	}
	
	dispatch def createNode(IOutlineNode parent, MultiAssociation multiAsso) {
		val associationNode = createEObjectNode(parent, multiAsso);
		for (memberEnd : multiAsso.connectorEnds) {
			createNode(associationNode, memberEnd.type)
		}
	}
	
	def _createChildren(IOutlineNode parent, Method method) {
		for (param : method.parameters) {
			createNode(parent, param)
		}
	}
	
	dispatch def isLeaf(Method meth) {
		return meth.parameters.isEmpty
	}
	
	dispatch def isLeaf(Attribute att) {
		return true;
	}
	
	dispatch def isLeaf(Parameter param) {
		return true;
	}
	
	dispatch def isLeaf(CommentLink comLink) {
		return true;
	}
	
	private def getStyledString(String name, int counter) {
		var styledLabel = new StyledString()
		styledLabel.append(name)
		styledLabel.append(new StyledString(" : " + counter, StyledString::DECORATIONS_STYLER))
		return styledLabel
	}

}
