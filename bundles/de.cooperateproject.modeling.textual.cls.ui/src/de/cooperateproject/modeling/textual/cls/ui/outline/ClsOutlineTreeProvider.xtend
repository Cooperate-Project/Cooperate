/*
 * generated by Xtext
 */
package de.cooperateproject.modeling.textual.cls.ui.outline

import com.google.common.base.Predicate
import de.cooperateproject.modeling.textual.cls.cls.ClassDiagram
import de.cooperateproject.modeling.textual.cls.cls.ClsPackage
import de.cooperateproject.modeling.textual.cls.cls.CommentLink
import de.cooperateproject.modeling.textual.cls.cls.Commentable
import de.cooperateproject.modeling.textual.cls.cls.Connector
import de.cooperateproject.modeling.textual.cls.cls.Package
import de.cooperateproject.modeling.textual.cls.ui.labeling.UMLImageGetter
import java.util.Collection
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.jdt.ui.ISharedImages
import org.eclipse.jdt.ui.JavaUI
import org.eclipse.jface.viewers.StyledString
import org.eclipse.swt.graphics.Image
import org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider
import org.eclipse.xtext.ui.editor.outline.impl.EStructuralFeatureNode

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#outline
 */
class ClsOutlineTreeProvider extends DefaultOutlineTreeProvider {
	
	val images = JavaUI.getSharedImages();

	dispatch def createChildren(AbstractOutlineNode parentNode, ClassDiagram root) {
		if (root.rootPackage == null) {
			return
		}
		createNode(parentNode, root.rootPackage)
	}
	
	dispatch def createChildren(AbstractOutlineNode parentNode, Package pkg) {
		ceateFeatureNode(parentNode, pkg, ClsPackage.Literals.PACKAGE__PACKAGES, UMLImageGetter.getUMLImage("Package.gif"), getStyledString("Packages", pkg.packages.size), false)
		ceateFeatureNode(parentNode, pkg, ClsPackage.Literals.PACKAGE__PACKAGE_IMPORTS, images.getImage(ISharedImages.IMG_OBJS_IMPCONT), getStyledString("Imports", pkg.packageImports.size), false)
		ceateFeatureNode(parentNode, pkg, ClsPackage.Literals.PACKAGE__CLASSIFIERS, images.getImage(ISharedImages.IMG_OBJS_CLASS), getStyledString("Classifiers", pkg.classifiers.size), false)
		ceateFeatureNode(parentNode, pkg, ClsPackage.Literals.PACKAGE__CONNECTORS, UMLImageGetter.getUMLImage("Association.gif"), getStyledString("Connectors", pkg.connectors.size), false)
		ceateFeatureNode(parentNode, pkg, ClsPackage.Literals.PACKAGE__CONNECTORS, UMLImageGetter.getUMLImage("Comment.gif"), getStyledString("Comments", pkg.connectors.filter(Commentable).filter[comment != null].size), false, [!pkg.connectors.filter(Commentable).filter[comment != null].empty])
	}
	
	protected def dispatch createNode(EStructuralFeatureNode parentNode, Connector c) {
		if ((parentNode.text as StyledString).toString.contains("Comments")) {
			createCommentNode(parentNode, c)
		} else {
			createConnectorNode(parentNode, c)
		}
	}
	
	def dispatch createCommentNode(AbstractOutlineNode parentNode, Commentable connector) {
		if (connector.comment != null) {
			createEObjectNode(parentNode, connector)
		}
	}
	
	def dispatch createCommentNode(AbstractOutlineNode parentNode, Connector connector) {
		// do nothing
	}
	
	def dispatch createConnectorNode(AbstractOutlineNode parentNode, Connector connector) {
		createEObjectNode(parentNode, connector)
	}
	
	def dispatch createConnectorNode(AbstractOutlineNode parentNode, CommentLink connector) {
		// do nothing
	}
	
	
	private def getStyledString(String name, int counter) {
		var styledLabel = new StyledString()
		styledLabel.append(name)
		styledLabel.append(new StyledString(" : " + counter, StyledString::DECORATIONS_STYLER))
		return styledLabel
	}
	
	
	private def <T extends EObject> ceateFeatureNode(AbstractOutlineNode parentNode, T parent, EReference ref, Image img, StyledString text, boolean isLeaf) {
		val result = parent.eGet(ref);
		if (result instanceof Collection<?>) {
			ceateFeatureNode(parentNode, parent, ref, img, text, isLeaf, [!result.empty])
		} else if (result != null) {
			ceateFeatureNode(parentNode, parent, ref, img, text, isLeaf, [true])
		}
	}
	
	private def <T extends EObject> ceateFeatureNode(AbstractOutlineNode parentNode, T parent, EReference ref, Image img, StyledString text, boolean isLeaf, Predicate<T> pred) {
		if (pred.apply(parent)) {
			createEStructuralFeatureNode(parentNode, parent, ref, img, text, false)		
		}
	}

}
