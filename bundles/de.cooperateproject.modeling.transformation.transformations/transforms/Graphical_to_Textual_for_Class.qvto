import TransformationUtils_Class;

transformation PapyrusClass2Text(in graphical : NOTATION, inout textual : TXT, in umlmodel : UML, in umlprimitives : UML);

modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype TXT uses cls('http://www.cooperateproject.de/modeling/textual/cls/Cls');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
	var diagrams := graphical.rootObjects()[notation::Diagram]->select(type="PapyrusUMLClassDiagram");
	assert fatal (diagrams->size() = 1);

	diagrams->map diagramToDiagram();
}

mapping notation::Diagram::diagramToDiagram() : cls::ClassDiagram {
	title := self.name;
	rootPackage := self.map diagramToRootPackage();
}

mapping notation::Diagram::diagramToRootPackage() : cls::Package {
	var relevantEdges := self.findRelevantEdges();

	referencedElement := self.element.oclAsType(uml::Package);
		
	classifiers += self.children->select(type = PAPYRUS_NOTATION_SHAPE_CLASS_REGULAR or type = PAPYRUS_NOTATION_SHAPE_INTERFACE_REGULAR)->map nodeToClassifier();
	connectors += self.findRelevantAssociationBranches()->map associationNodeToMultiAssociation(self.edges);
	connectors += self.edges->select(not isCommentLinkForAssociation())->map edgeToConnector(self.edges);
	packageImports += relevantEdges->select(type = PAPYRUS_NOTATION_EDGE_PACKAGEIMPORT)->map edgeToPackageImport();
	packages += self.children->select(type = PAPYRUS_NOTATION_SHAPE_PACKAGE_REGULAR)->map nodeToPackage();
}

mapping notation::Node::nodeToPackage() : cls::Package
{
	var umlPackage := self.element.oclAsType(uml::Package);
	var relevantEdges := self.findRelevantEdges();
	var packagedElementsNode := self.children->select(type = PAPYRUS_NOTATION_COMPARTMENT_PACKAGE_PACKAGEABLE_INPACKAGE or type = PAPYRUS_NOTATION_COMPARTMENT_PACKAGE_PACKAGEABLE_REGULAR);
	
	referencedElement := umlPackage;
	classifiers += packagedElementsNode.children->select(type = PAPYRUS_NOTATION_SHAPE_CLASS_INPACKAGE or type = PAPYRUS_NOTATION_SHAPE_INTERFACE_INPACKAGE)->map nodeToClassifier();
	connectors += self.findRelevantAssociationBranches()->select(element.oclAsType(uml::Element).getNearestPackage() = umlPackage)->map associationNodeToMultiAssociation(self.diagram.edges);
	connectors += relevantEdges->select(not isCommentLinkForAssociation())->map edgeToConnector(self.diagram.edges);
	packageImports += relevantEdges->select(type = PAPYRUS_NOTATION_EDGE_PACKAGEIMPORT)->map edgeToPackageImport();
	packages += packagedElementsNode.children->select(type = PAPYRUS_NOTATION_SHAPE_PACKAGE_INPACKAGE)->map nodeToPackage();
}

query notation::Diagram::findRelevantEdges() : OrderedSet(notation::Edge)
{
	return self.findRelevantEdgesByContainment();
}

query notation::Node::findRelevantEdges() : OrderedSet(notation::Edge)
{
	return self.findRelevantEdgesByContainment();
}

/*
query notation::View::findRelevantEdgesByHeuristics() : OrderedSet(notation::Edge)
{
	assert fatal (self.element.oclIsKindOf(uml::Package)) with log('Finding relevant edges is only possible for views that represent packages.');
	var umlPackage = self.element.oclAsType(uml::Package);

	// associations
	var relevantAssociations := self.diagram.edges->select(type = PAPYRUS_NOTATION_EDGE_ASSOCIATION)->select(
		// all navigable ends are in umlPackage
		element.oclAsType(uml::Association).memberEnd->select(isNavigable() and getNearestPackage() != umlPackage)->isEmpty()
		or
		// Convention: The association belongs to the package in which the first navigable member end is located
		element.oclAsType(uml::Association).memberEnd->select(isNavigable())->first().getNearestPackage() = umlPackage
	);
	
	// multi associations
	var relevantAssociationBranches := self.diagram.edges->select(type = PAPYRUS_NOTATION_EDGE_ASSOCIATIONBRANCH);
	
	// comment links
	var relevantCommentLinks := self.diagram.edges->select(type = PAPYRUS_NOTATION_EDGE_COMMENTLINK)->select(source.element->asSet()->union(target.element->asSet())->any(oclIsKindOf(uml::Classifier)).oclAsType(uml::Classifier).getNearestPackage() = umlPackage);
	
	// interface realizations
	var relevantInterfaceRealizations := self.diagram.edges->select(type = PAPYRUS_NOTATION_EDGE_IMPLEMENTATION)->select(element.oclAsType(uml::InterfaceRealization).implementingClassifier.getNearestPackage()->select(p | p != umlPackage)->isEmpty());
	
	// generalizations
	var relevantGeneralizations := self.diagram.edges->select(type = PAPYRUS_NOTATION_EDGE_GENERALIZATION)->select(element.oclAsType(uml::Generalization).specific.getNearestPackage() = umlPackage);

	// package imports
	var relevantPackageImports := self.diagram.edges->select(type = PAPYRUS_NOTATION_EDGE_PACKAGEIMPORT)->select(element.oclAsType(uml::PackageImport).importingNamespace = umlPackage);

	// maintain edge order	
	return self.diagram.edges->select(e | relevantAssociations->union(relevantAssociationBranches)->union(relevantCommentLinks)->union(relevantInterfaceRealizations)->union(relevantGeneralizations)->union(relevantPackageImports)->asSet()->includes(e));
}
*/

query notation::View::findRelevantEdgesByContainment() : OrderedSet(notation::Edge)
{
	assert fatal (self.element.oclIsKindOf(uml::Package)) with log('Finding relevant edges is only possible for views that represent packages.');
	var umlPackage = self.element.oclAsType(uml::Package);

	return self.diagram.edges->select(findOwningPackage() = umlPackage);
} 

query notation::Edge::findOwningPackage() : uml::Package
{
	return if self.oclIsKindOf(notation::Connector) then self.oclAsType(notation::Connector).findOwningPackage() else null endif;
}

query notation::Connector::findOwningPackage() : uml::Package
{
	return
		if self.element != null then
			self.element.oclAsType(uml::Element).getNearestPackage()
		else
			self.source.element->asSet()->union(self.target.element->asSet())->selectByKind(uml::Classifier)->any(true).getNearestPackage()
		endif;
}

query notation::View::findRelevantAssociationBranches() : OrderedSet(notation::Node)
{
	assert fatal (self.element.oclIsKindOf(uml::Package)) with log('Finding relevant edges is only possible for views that represent packages.');
	var umlPackage = self.element.oclAsType(uml::Package);
	
	return self.diagram.children->select(type = PAPYRUS_NOTATION_SHAPE_NARY_REGULAR)->select(true);
}

mapping notation::Edge::edgeToPackageImport() : cls::PackageImport
{
	assert error (self.element.oclIsKindOf(uml::PackageImport)) with log('Only edges containing a package import can be mapped to a package import.');
	referencedElement := self.element.oclAsType(uml::PackageImport);
}

mapping notation::Node::nodeToClassifier() : cls::Classifier
	disjuncts notation::Node::nodeToClass, notation::Node::nodeToInterface
{
}

mapping notation::Node::nodeToClass() : cls::Class
	when {
		self.element.oclIsKindOf(uml::Class)
	}
{
	var clz := self.element.oclAsType(uml::Class);
	referencedElement := clz;
	
	_abstract := clz.isAbstract;
	
	aliasExpression := clz.nameExpression; 
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Property)))-> map nodeToProperty();
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Operation)))->map nodeToOperation();
}

mapping notation::Node::nodeToInterface() : cls::Interface
	when {
		self.element.oclIsKindOf(uml::Interface)
	}
{
	var interface := self.element.oclAsType(uml::Interface);
	referencedElement := interface;
	
	aliasExpression := interface.nameExpression;
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Property)))-> map nodeToProperty();
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Operation)))->map nodeToOperation();
}

mapping notation::Node::nodeToOperation() : cls::Method {
	var operation := self.element.oclAsType(uml::Operation);
	referencedElement := operation;
	visibility := operation.visibility.covert();
	_static := operation.isStatic;
	final := operation.isLeaf;
	_abstract := operation.isAbstract;
	type := operation.type.map typeToTypeReference(result);
	parameters += operation.ownedParameter->select(direction != uml::ParameterDirectionKind::_return) ->map umlParameterToParameter();
}

mapping uml::Parameter::umlParameterToParameter() : cls::Parameter {
	referencedElement := self;
	visibility := self.visibility.covert();
	type := self.type.map typeToTypeReference(result);
}

mapping notation::Node::nodeToProperty() : cls::Attribute {
	var prop := self.element.oclAsType(uml::Property);
	referencedElement := prop;
	visibility := prop.visibility.covert();
	_static := prop.isStatic;
	final := prop.isLeaf;
	type := prop.type.map typeToTypeReference(result);
}

mapping uml::Type::typeToTypeReference(parent : OclAny) : cls::TypeReference 
disjuncts uml::Type::typeToPrimitiveTypeReference, uml::Type::typeToUMLTypeReference 
{
}


mapping uml::Type::typeToPrimitiveTypeReference(parent : OclAny) : cls::DataTypeReference 
	when {self.oclIsKindOf(uml::PrimitiveType)}
{
	type := self.oclAsType(uml::PrimitiveType).convert();
}

mapping uml::Type::typeToUMLTypeReference(parent : OclAny) : cls::UMLTypeReference
	when {not self.oclIsKindOf(uml::PrimitiveType)}
{
	type := self;
}

mapping uml::Type::typeToUMLTypeReference2(parent : OclAny, discriminator : OclAny) : cls::UMLTypeReference
	when {not self.oclIsKindOf(uml::PrimitiveType)}
{
	type := self;
}

mapping notation::Edge::edgeToConnector(allEdges : OrderedSet(Edge)) : cls::Connector
disjuncts
	notation::Edge::edgeToCommentLink,
	notation::Edge::edgeToGeneralization,
	notation::Edge::edgeToImplementation,
	notation::Edge::edgeToRegularAssociation
{}

mapping notation::Edge::edgeToCommentLink(allEdges : OrderedSet(Edge)) : cls::CommentLink
	when {self.isCommentLink()}
{
	var classifier := if self.source.element.oclIsKindOf(uml::Classifier) then self.source.element else self.target.element endif;
	var umlComment := if self.source.element.oclIsKindOf(uml::Comment) then self.source.element else  self.target.element endif; 
	left := classifier.oclAsType(uml::Classifier).map typeToUMLTypeReference(result);
	comment := umlComment.oclAsType(uml::Comment);
}

mapping notation::Edge::edgeToGeneralization(allEdges : OrderedSet(Edge)) : cls::Generalization
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Generalization)
	}
{
	var association := self.element.oclAsType(uml::Generalization);
	assert error (association.source->size() = 1 and association.target->size() = 1) with log ('Generalizations must of exactly one source and one target.', association);
	
	left := association.specific.map typeToUMLTypeReference(result);
	right := association.general.map typeToUMLTypeReference(result);
}

mapping notation::Edge::edgeToImplementation(allEdges : OrderedSet(Edge)) : cls::Implementation
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::InterfaceRealization)
	}
{
	var association := self.element.oclAsType(uml::InterfaceRealization);
	assert error (association.source->size() = 1 and association.target->size() = 1) with log ('Interface realizations must of exactly one source and one target.', association);
	
	left := association.implementingClassifier.map typeToUMLTypeReference(result);
	right := association.contract.map typeToUMLTypeReference(result);
}

mapping notation::Edge::edgeToRegularAssociation(allEdges : OrderedSet(Edge)) : cls::Association
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Association) and
		self.element.oclAsType(uml::Association).memberEnd->size() = 2
	}
{
	var association := self.element.oclAsType(uml::Association);

	/*
		NOTE: The aggregation symbol is shown at the property that is the opposite of the property
		      with a set aggregation kind
		      UML 2.5, 11.5.4
	*/
	
	var navigableEnds := association.findNavigableEnds();
	assert warning (navigableEnds->notEmpty()) with log('An association with no navigable end is not useful.');
		
	
	var aggregatingIndex := if association.memberEnd->at(2).aggregation != uml::AggregationKind::none then 2 else 1 endif;
	var regularIndex := if aggregatingIndex = 2 then 1 else 2 endif;
	
	referencedElement := association;
	aggregationKind := association.memberEnd->at(aggregatingIndex).aggregation.convert();
	left := association.memberEnd->at(regularIndex).type.map typeToUMLTypeReference2(result, regularIndex);
	right := association.memberEnd->at(aggregatingIndex).type.map typeToUMLTypeReference2(result, aggregatingIndex);
		bidirectional := association.memberEnd->select(e | not e.isNavigable())->isEmpty();
	
	properties := self.map edgeToAssociationProperties(regularIndex);
	
	var relevantComments := self.findEdgeComments(allEdges);
	assert warning (relevantComments->size() < 2) with log ('There can be no more than one comments for an association.');
	comment := relevantComments->any(true);
}

query uml::Association::findNavigableEnds() : OrderedSet(Property)
{
	return self.memberEnd->select(it | it.owner != self or self.navigableOwnedEnd->includes(it))
}

mapping notation::Edge::edgeToAssociationProperties(firstIndex : Integer) : cls::AssociationProperties
when {self.element.oclIsKindOf(uml::Association)}
{
	var umlAssociation := self.element.oclAsType(uml::Association);
	assert error (umlAssociation.memberEnd->size() = 2) with log('Could not transform association because there are not exactly two association ends.', self);
		
	var left := umlAssociation.memberEnd->at(firstIndex);
	var right := umlAssociation.memberEnd->at(if firstIndex = 1 then 2 else 1 endif);
	
	cardinalityLeft := left.map multiplicityElementToCardinality();
	cardinalityRight := right.map multiplicityElementToCardinality();
	
	propertyLeft := if self.children->exists(type = PAPYRUS_NOTATION_NODE_ASSOCIATION_SOURCEROLE) then left else null endif;
	propertyRight := if self.children->exists(type = PAPYRUS_NOTATION_NODE_ASSOCIATION_TARGETROLE) then right else null endif;
}


mapping uml::MultiplicityElement::multiplicityElementToCardinality() : cls::Cardinality {
	lowerBound := self.lower;
	upperBound := self.upper;
}


//TODO never called
mapping notation::Node::nodeToCommentConnector() : cls::CommentLink
	when {
		self.element.oclIsKindOf(uml::Comment) and
		self.element.oclAsType(uml::Comment).annotatedElement->forAll(not oclIsKindOf(uml::Association) and oclIsKindOf(uml::Classifier))
	}
{
	var commentElement := self.element.oclAsType(uml::Comment);
	assert error (commentElement.annotatedElement->size() = 1) with log ("Comments must not comment more than one element.", commentElement);
	
	left := commentElement.annotatedElement->any(true).oclAsType(uml::Classifier).map typeToUMLTypeReference(result);
	comment := comment;
}


mapping notation::Node::associationNodeToMultiAssociation(allEdges : OrderedSet(notation::Edge)) : cls::MultiAssociation
	when {
		self.element.oclIsKindOf(uml::Association) and self.element.oclAsType(uml::Association).memberEnd->size() > 2
	}
{
	var umlAssociation := self.element.oclAsType(uml::Association);
	referencedElement := umlAssociation;
	
	var accordingEdges := allEdges->select(type = PAPYRUS_NOTATION_EDGE_ASSOCIATIONBRANCH and (source = self or target = self));
	connectorEnds += accordingEdges->map edgeToMemberEnd();
	//connectorEnds += umlAssociation.memberEnd->map propertyToMemberEnd();
}

mapping notation::Edge::edgeToMemberEnd() : cls::MemberEnd
{
	var umlProperty := self.styles->selectByKind(notation::EObjectValueStyle)->any(name = "Semantic_Branch_Style").eObjectValue.oclAsType(uml::Property);
	referencedElement := if umlProperty.name != null then umlProperty else null endif;
	cardinality := umlProperty.map multiplicityElementToCardinality();
	type := umlProperty.type.map typeToUMLTypeReference(result);
	navigable := umlProperty.association.navigableOwnedEnd->includes(umlProperty);
}

/*
mapping uml::Property::propertyToMemberEnd() : cls::MemberEnd
{
	referencedElement := if self.name != null then self else null endif;
	cardinality := self.map multiplicityElementToCardinality();
	type := self.type.map typeToUMLTypeReference(result);
	navigable := self.association.navigableOwnedEnd->includes(self);
}
*/

query notation::Edge::isCommentLink() : Boolean {
	return self.element = null and (
			(
				self.source.element.oclIsKindOf(uml::Comment) and
				self.target.element.oclIsKindOf(uml::Classifier)
			)
			or
			(
				self.source.element.oclIsKindOf(uml::Classifier) and
				self.target.element.oclIsKindOf(uml::Comment)
			)
		)
}

query notation::Edge::isCommentLinkForAssociation() : Boolean {
	return self.isCommentLink() and (self.source.element.oclAsSet()->union(self.target.element.oclAsSet())->exists(oclIsKindOf(uml::Association)));
}

query notation::Edge::findEdgeComments(allEdges : OrderedSet(notation::Edge)) : OrderedSet(uml::Comment) {
	return
		allEdges->select(source = self and target.element.oclIsKindOf(uml::Comment))->collect(target.element.oclAsType(uml::Comment))
		->union(
		allEdges->select(target = self and source.element.oclIsKindOf(uml::Comment))->collect(source.element.oclAsType(uml::Comment))
		)->asOrderedSet();
}

query uml::PrimitiveType::convert() : cls::PrimitiveType {
	switch {
		case (self.name = "Real") {return cls::PrimitiveType::DOUBLE}
		case (self.name = "EDouble") {return cls::PrimitiveType::DOUBLE}
		case (self.name = "Integer") {return cls::PrimitiveType::INT}
		case (self.name = "EInt") {return cls::PrimitiveType::INT}
		case (self.name = "Boolean") {return cls::PrimitiveType::BOOLEAN}
		case (self.name = "EBoolean") {return cls::PrimitiveType::BOOLEAN}
		case (self.name = "EByte") {return cls::PrimitiveType::BYTE}
		case (self.name = "EChar") {return cls::PrimitiveType::CHAR}
		case (self.name = "EFloat") {return cls::PrimitiveType::FLOAT}
		case (self.name = "ELong") {return cls::PrimitiveType::LONG}
		case (self.name = "EShort") {return cls::PrimitiveType::SHORT}
		case (self.name = "String") {return cls::PrimitiveType::STRING}
		case (self.name = "EString") {return cls::PrimitiveType::STRING}
	};
	assert error (false) with log('Could not convert primitive UML type.', self);
	return null;
}

query uml::VisibilityKind::covert() : cls::Visibility {
	switch {
		case(self = uml::VisibilityKind::public) {return cls::Visibility::PUBLIC}
		case(self = uml::VisibilityKind::private) {return cls::Visibility::PRIVATE}
		case(self = uml::VisibilityKind::protected) {return cls::Visibility::PROTECTED}
		case(self = uml::VisibilityKind::package) {return cls::Visibility::PACKAGE}
	};
	assert error (false) with log('Could not convert UML visibility type.', self);
	return null;
}

query uml::AggregationKind::convert() : cls::AggregationKind {
	switch {
		case(self = uml::AggregationKind::none) {return cls::AggregationKind::NONE}
		case(self = uml::AggregationKind::shared) {return cls::AggregationKind::AGGREGATION}
		case(self = uml::AggregationKind::composite) {return cls::AggregationKind::COMPOSITION}
	};
	assert error (false) with log('Could not convert UML aggregation kind.', self);
	return null;
}
