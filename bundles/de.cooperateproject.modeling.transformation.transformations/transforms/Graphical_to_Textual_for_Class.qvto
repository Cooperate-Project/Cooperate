transformation PapyrusClass2Text(in graphical : NOTATION, out textual : TXT, in umlmodel : UML, in umlprimitives : UML);

modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype TXT uses cls('http://www.cooperateproject.de/modeling/textual/cls/Cls');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');

property TYPES_SHAPE_NARY : String = "2015";	

main() {
	var diagrams := graphical.rootObjects()[notation::Diagram]->select(type="PapyrusUMLClassDiagram");
	assert fatal (diagrams->size() = 1);

	diagrams->map diagramToDiagram();
}

mapping notation::Diagram::diagramToDiagram() : cls::ClassDiagram {
	name := self.name;
	packageImports += self->map diagramToPackageImport();
	classifiers += self.children->select(element.oclIsKindOf(uml::Class) or element.oclIsKindOf(uml::Interface))->map nodeToClassifier();
	connectors += self.children->select(type = TYPES_SHAPE_NARY)->map associationNodeToMultiAssociation(self.edges);
	connectors += self.edges->select(not isCommentLinkForAssociation())->map edgeToConnector(self.edges);
}

mapping notation::Diagram::diagramToPackageImport() : cls::PackageImport {
	package := self.element.oclAsType(uml::Package);
}

mapping notation::Node::nodeToClassifier() : cls::Classifier
	disjuncts notation::Node::nodeToClass, notation::Node::nodeToInterface
{
}

mapping notation::Node::nodeToClass() : cls::Class
	when {
		self.element.oclIsKindOf(uml::Class)
	}
{
	var clz := self.element.oclAsType(uml::Class);
	referencedElement := clz;
	
	_abstract := clz.isAbstract;
	
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Property)))-> map nodeToProperty();
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Operation)))->map nodeToOperation();
}

mapping notation::Node::nodeToInterface() : cls::Interface
	when {
		self.element.oclIsKindOf(uml::Interface)
	}
{
	var interface := self.element.oclAsType(uml::Interface);
	referencedElement := interface;
	
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Property)))-> map nodeToProperty();
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Operation)))->map nodeToOperation();
}

mapping notation::Node::nodeToOperation() : cls::Method {
	var operation := self.element.oclAsType(uml::Operation);
	referencedElement := operation;
	visibility := operation.visibility.covert();
	_static := operation.isStatic;
	final := operation.isLeaf;
	_abstract := operation.isAbstract;
	type := operation.type.map typeToTypeReference(result);
	parameters += operation.ownedParameter->select(direction != uml::ParameterDirectionKind::_return) ->map umlParameterToParameter();
}

mapping uml::Parameter::umlParameterToParameter() : cls::Parameter {
	referencedElement := self;
	visibility := self.visibility.covert();
	type := self.type.map typeToTypeReference(result);
}

mapping notation::Node::nodeToProperty() : cls::Attribute {
	var prop := self.element.oclAsType(uml::Property);
	referencedElement := prop;
	visibility := prop.visibility.covert();
	_static := prop.isStatic;
	final := prop.isLeaf;
	type := prop.type.map typeToTypeReference(result);
}

mapping uml::Type::typeToTypeReference(parent : OclAny) : cls::TypeReference 
disjuncts uml::Type::typeToPrimitiveTypeReference, uml::Type::typeToUMLTypeReference 
{
}


mapping uml::Type::typeToPrimitiveTypeReference(parent : OclAny) : cls::DataTypeReference 
	when {self.oclIsKindOf(uml::PrimitiveType)}
{
	type := self.oclAsType(uml::PrimitiveType).convert();
}

mapping uml::Type::typeToUMLTypeReference(parent : OclAny) : cls::UMLTypeReference
	when {not self.oclIsKindOf(uml::PrimitiveType)}
{
	type := self;
}

/*
constructor cls::DataTypeReference::DataTypeReference(umlType : uml::PrimitiveType) {
	type := umlType.convert();
}

constructor cls::UMLTypeReference::UMLTypeReference(umlType : uml::Type) {
	type := umlType;
}
*/

mapping notation::Edge::edgeToConnector(allEdges : OrderedSet(Edge)) : cls::Connector
disjuncts
	notation::Edge::edgeToCommentLink,
	notation::Edge::edgeToGeneralization,
	notation::Edge::edgeToImplementation,
	notation::Edge::edgeToRegularAssociation
{}

mapping notation::Edge::edgeToCommentLink(allEdges : OrderedSet(Edge)) : cls::CommentLink
	when {self.isCommentLink()}
{
	var classifier := if self.source.element.oclIsKindOf(uml::Classifier) then self.source.element else self.target.element endif;
	var umlComment := if self.source.element.oclIsKindOf(uml::Comment) then self.source.element else  self.target.element endif; 
	left := classifier.oclAsType(uml::Classifier).map typeToUMLTypeReference(result);
	comment := umlComment.oclAsType(uml::Comment);
}

mapping notation::Edge::edgeToGeneralization(allEdges : OrderedSet(Edge)) : cls::Generalization
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Generalization)
	}
{
	var association := self.element.oclAsType(uml::Generalization);
	assert error (association.source->size() = 1 and association.target->size() = 1) with log ('Generalizations must of exactly one source and one target.', association);
	
	left := association.specific.map typeToUMLTypeReference(result);
	right := association.general.map typeToUMLTypeReference(result);
}

mapping notation::Edge::edgeToImplementation(allEdges : OrderedSet(Edge)) : cls::Implementation
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::InterfaceRealization)
	}
{
	var association := self.element.oclAsType(uml::InterfaceRealization);
	assert error (association.source->size() = 1 and association.target->size() = 1) with log ('Interface realizations must of exactly one source and one target.', association);
	
	left := association.implementingClassifier.map typeToUMLTypeReference(result);
	right := association.contract.map typeToUMLTypeReference(result);
}

mapping notation::Edge::edgeToRegularAssociation(allEdges : OrderedSet(Edge)) : cls::Association
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Association) and
		self.element.oclAsType(uml::Association).memberEnd->size() = 2
	}
{
	var association := self.element.oclAsType(uml::Association);

	/*
		NOTE: The aggregation symbol is shown at the property that is the opposite of the property
		      with a set aggregation kind
		      UML 2.5, 11.5.4
	*/
	
	var navigableEnds := association.findNavigableEnds();
	assert warning (navigableEnds->notEmpty()) with log('An association with no navigable end is not useful.');
		
	
	var aggregatingIndex := if association.memberEnd->at(2).aggregation != uml::AggregationKind::none then 2 else 1 endif;
	var regularIndex := if aggregatingIndex = 2 then 1 else 2 endif;
	
	referencedElement := association;
	aggregationKind := association.memberEnd->at(aggregatingIndex).aggregation.convert();
	left := association.memberEnd->at(regularIndex).type.map typeToUMLTypeReference(result);
	right := association.memberEnd->at(aggregatingIndex).type.map typeToUMLTypeReference(result);
	
	properties := association.map edgeToAssociationProperties(regularIndex);
	
	var relevantComments := self.findEdgeComments(allEdges);
	assert warning (relevantComments->size() = 1) with log ('There can be no more than one comments for an association.');
	comment := relevantComments->any(true);
}

query uml::Association::findNavigableEnds() : OrderedSet(Property)
{
	return self.memberEnd->select(it | it.owner != self or self.navigableOwnedEnd->includes(it))
}

mapping uml::Association::edgeToAssociationProperties(firstIndex : Integer) : cls::AssociationProperties {
	assert error (self.memberEnd->size() = 2) with log('Could not transform association because there are not exactly two association ends.', self);
		
	var left := self.memberEnd->at(firstIndex);
	var right := self.memberEnd->at(if firstIndex = 1 then 2 else 1 endif);
	
	cardinalityLeft := left.map multiplicityElementToCardinality();
	cardinalityRight := right.map multiplicityElementToCardinality();
}


mapping uml::MultiplicityElement::multiplicityElementToCardinality() : cls::Cardinality {
	lowerBound := self.lower;
	upperBound := self.upper;
}


//TODO never called
mapping notation::Node::nodeToCommentConnector() : cls::CommentLink
	when {
		self.element.oclIsKindOf(uml::Comment) and
		self.element.oclAsType(uml::Comment).annotatedElement->forAll(not oclIsKindOf(uml::Association) and oclIsKindOf(uml::Classifier))
	}
{
	var commentElement := self.element.oclAsType(uml::Comment);
	assert error (commentElement.annotatedElement->size() = 1) with log ("Comments must not comment more than one element.", commentElement);
	
	left := commentElement.annotatedElement->any(true).oclAsType(uml::Classifier).map typeToUMLTypeReference(result);
	comment := comment;
}


mapping notation::Node::associationNodeToMultiAssociation(allEdges : OrderedSet(notation::Edge)) : cls::MultiAssociation
	when {
		self.element.oclIsKindOf(uml::Association) and self.element.oclAsType(uml::Association).memberEnd->size() > 2
	}
{
	var umlAssociation := self.element.oclAsType(uml::Association);
	referencedElement := umlAssociation;
	
	var accordingEdges := allEdges->select(type = "4019" and (source = self or target = self));
	connectorEnds += accordingEdges->map edgeToMemberEnd();
	//connectorEnds += umlAssociation.memberEnd->map propertyToMemberEnd();
}

mapping notation::Edge::edgeToMemberEnd() : cls::MemberEnd
{
	var umlProperty := self.styles->selectByKind(notation::EObjectValueStyle)->any(name = "Semantic_Branch_Style").eObjectValue.oclAsType(uml::Property);
	referencedElement := if umlProperty.name != null then umlProperty else null endif;
	cardinality := umlProperty.map multiplicityElementToCardinality();
	type := umlProperty.type.map typeToUMLTypeReference(result);
	navigable := umlProperty.association.navigableOwnedEnd->includes(umlProperty);
}

/*
mapping uml::Property::propertyToMemberEnd() : cls::MemberEnd
{
	referencedElement := if self.name != null then self else null endif;
	cardinality := self.map multiplicityElementToCardinality();
	type := self.type.map typeToUMLTypeReference(result);
	navigable := self.association.navigableOwnedEnd->includes(self);
}
*/

query notation::Edge::isCommentLink() : Boolean {
	return self.element = null and (
			(
				self.source.element.oclIsKindOf(uml::Comment) and
				self.target.element.oclIsKindOf(uml::Classifier)
			)
			or
			(
				self.source.element.oclIsKindOf(uml::Classifier) and
				self.target.element.oclIsKindOf(uml::Comment)
			)
		)
}

query notation::Edge::isCommentLinkForAssociation() : Boolean {
	return self.isCommentLink() and (self.source.element.oclAsSet()->union(self.target.element.oclAsSet())->exists(oclIsKindOf(uml::Association)));
}

query notation::Edge::findEdgeComments(allEdges : OrderedSet(notation::Edge)) : OrderedSet(uml::Comment) {
	return
		allEdges->select(source = self and target.element.oclIsKindOf(uml::Comment))->collect(target.element.oclAsType(uml::Comment))
		->union(
		allEdges->select(target = self and source.element.oclIsKindOf(uml::Comment))->collect(source.element.oclAsType(uml::Comment))
		)->asOrderedSet();
}

query uml::PrimitiveType::convert() : cls::PrimitiveType {
	switch {
		case (self.name = "Real") {return cls::PrimitiveType::DOUBLE}
		case (self.name = "EDouble") {return cls::PrimitiveType::DOUBLE}
		case (self.name = "Integer") {return cls::PrimitiveType::INT}
		case (self.name = "EInt") {return cls::PrimitiveType::INT}
		case (self.name = "Boolean") {return cls::PrimitiveType::BOOLEAN}
		case (self.name = "EBoolean") {return cls::PrimitiveType::BOOLEAN}
		case (self.name = "EByte") {return cls::PrimitiveType::BYTE}
		case (self.name = "EChar") {return cls::PrimitiveType::CHAR}
		case (self.name = "EFloat") {return cls::PrimitiveType::FLOAT}
		case (self.name = "ELong") {return cls::PrimitiveType::LONG}
		case (self.name = "EShort") {return cls::PrimitiveType::SHORT}
		case (self.name = "String") {return cls::PrimitiveType::STRING}
		case (self.name = "EString") {return cls::PrimitiveType::STRING}
	};
	assert error (false) with log('Could not convert primitive UML type.', self);
	return null;
}

query uml::VisibilityKind::covert() : cls::Visibility {
	switch {
		case(self = uml::VisibilityKind::public) {return cls::Visibility::PUBLIC}
		case(self = uml::VisibilityKind::private) {return cls::Visibility::PRIVATE}
		case(self = uml::VisibilityKind::protected) {return cls::Visibility::PROTECTED}
		case(self = uml::VisibilityKind::package) {return cls::Visibility::PACKAGE}
	};
	assert error (false) with log('Could not convert UML visibility type.', self);
	return null;
}

query uml::AggregationKind::convert() : cls::AggregationKind {
	switch {
		case(self = uml::AggregationKind::none) {return cls::AggregationKind::NONE}
		case(self = uml::AggregationKind::shared) {return cls::AggregationKind::AGGREGATION}
		case(self = uml::AggregationKind::composite) {return cls::AggregationKind::COMPOSITION}
	};
	assert error (false) with log('Could not convert UML aggregation kind.', self);
	return null;
}
