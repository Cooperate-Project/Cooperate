transformation PapyrusClass2Text(in graphical : NOTATION, out textual : TXT, in umlmodel : UML, in umlprimitives : UML);

modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype TXT uses cls('http://www.cooperateproject.de/modeling/textual/cls/Cls');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
	
main() {
	var diagrams := graphical.rootObjects()[notation::Diagram]->select(type="PapyrusUMLClassDiagram");
	assert fatal (diagrams->size() = 1);

	diagrams->map diagramToDiagram();
}

mapping notation::Diagram::diagramToDiagram() : cls::ClassDiagram {
	name := self.name;
	packageImports += self->map diagramToPackageImport();
	classifiers += self.children->select(element.oclIsKindOf(uml::Class) or element.oclIsKindOf(uml::Interface))->map nodeToClassifier();
	connectors += self.edges->map edgeToConnector(self.edges);
}

mapping notation::Diagram::diagramToPackageImport() : cls::PackageImport {
	package := self.element.oclAsType(uml::Package);
}

mapping notation::Node::nodeToClassifier() : cls::Classifier
	disjuncts notation::Node::nodeToClass, notation::Node::nodeToInterface
{
}

mapping notation::Node::nodeToClass() : cls::Class
	when {
		self.element.oclIsKindOf(uml::Class)
	}
{
	var clz := self.element.oclAsType(uml::Class);
	referencedElement := clz;
	
	_abstract := clz.isAbstract;
	
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Property)))-> map nodeToProperty();
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Operation)))->map nodeToOperation();
}

mapping notation::Node::nodeToInterface() : cls::Interface
	when {
		self.element.oclIsKindOf(uml::Interface)
	}
{
	var interface := self.element.oclAsType(uml::Interface);
	referencedElement := interface;
	
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Property)))-> map nodeToProperty();
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Operation)))->map nodeToOperation();
}

mapping notation::Node::nodeToOperation() : cls::Method {
	var operation := self.element.oclAsType(uml::Operation);
	referencedElement := operation;
	visibility := operation.visibility.covert();
	_static := operation.isStatic;
	final := operation.isLeaf;
	_abstract := operation.isAbstract;
	type := operation.type.typeToTypeReference();
	parameters += operation.ownedParameter->select(direction != uml::ParameterDirectionKind::_return) ->map umlParameterToParameter();
}

mapping uml::Parameter::umlParameterToParameter() : cls::Parameter {
	referencedElement := self;
	visibility := self.visibility.covert();
	type := self.type.typeToTypeReference();
}

mapping notation::Node::nodeToProperty() : cls::Attribute {
	var prop := self.element.oclAsType(uml::Property);
	referencedElement := prop;
	visibility := prop.visibility.covert();
	_static := prop.isStatic;
	final := prop.isLeaf;
	type := prop.type.typeToTypeReference();
}

/* we cannot do a mapping here, because we have to create a new
 * instance of the datatype for every call.
 */
query uml::Type::typeToTypeReference() : cls::TypeReference
{
	if self.oclIsTypeOf(uml::PrimitiveType) then
		return new DataTypeReference(self.oclAsType(uml::PrimitiveType))
	endif;
	return new UMLTypeReference(self)
}

constructor cls::DataTypeReference::DataTypeReference(umlType : uml::PrimitiveType) {
	type := umlType.convert();
}

constructor cls::UMLTypeReference::UMLTypeReference(umlType : uml::Type) {
	type := umlType;
}

mapping notation::Edge::edgeToConnector(allEdges : OrderedSet(Edge)) : cls::Connector
disjuncts
	notation::Edge::edgeToCommentLink1,
	notation::Edge::edgeToCommentLink2,
	notation::Edge::edgeToGeneralization,
	notation::Edge::edgeToImplementation,
	notation::Edge::edgeToAggregationOrComposition,
	notation::Edge::edgeToRegularAssociation
{}

mapping notation::Edge::edgeToCommentLink1(allEdges : OrderedSet(Edge)) : cls::CommentLink
	when {
		self.element = null and
		(
			self.source.element.oclIsKindOf(uml::Comment) and
			self.target.element.oclIsKindOf(uml::Classifier)
		)
	}
{
	left := new UMLTypeReference(self.target.element.oclAsType(uml::Classifier));
	comment := self.source.element.oclAsType(uml::Comment);
}

mapping notation::Edge::edgeToCommentLink2(allEdges : OrderedSet(Edge)) : cls::CommentLink
	when {
		self.element = null and
		(
			self.source.element.oclIsKindOf(uml::Classifier) and
			self.target.element.oclIsKindOf(uml::Comment) 
		)
	}
{
	left := new UMLTypeReference(self.source.element.oclAsType(uml::Classifier));
	comment := self.target.element.oclAsType(uml::Comment);
}

mapping notation::Edge::edgeToGeneralization(allEdges : OrderedSet(Edge)) : cls::Generalization
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Generalization)
	}
{
	var association := self.element.oclAsType(uml::Generalization);
	assert error (association.source->size() = 1 and association.target->size() = 1) with log ('Generalizations must of exactly one source and one target.', association);
	
	left := new UMLTypeReference(association.specific);
	right := new UMLTypeReference(association.general);
}

mapping notation::Edge::edgeToImplementation(allEdges : OrderedSet(Edge)) : cls::Implementation
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::InterfaceRealization)
	}
{
	var association := self.element.oclAsType(uml::InterfaceRealization);
	assert error (association.source->size() = 1 and association.target->size() = 1) with log ('Interface realizations must of exactly one source and one target.', association);
	
	left := new UMLTypeReference(association.implementingClassifier);
	right := new UMLTypeReference(association.contract);
}

mapping notation::Edge::edgeToAggregationOrComposition(allEdges : OrderedSet(Edge)) : cls::Association
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Association) and
		self.element.oclAsType(uml::Association).memberEnd->size() = 2 and
		self.element.oclAsType(uml::Association).memberEnd->at(2).aggregation != uml::AggregationKind::none
	}
{
	var association := self.element.oclAsType(uml::Association);
	
	referencedElement := association;
	aggregationKind := association.memberEnd->at(1).aggregation.convert();
	left := new UMLTypeReference(association.memberEnd->at(2).type);
	right := new UMLTypeReference(association.memberEnd->at(1).type);
	
	properties := association.map edgeToAssociationProperties(true);
	
	var relevantComments := self.findEdgeComments(allEdges);
	assert warning (relevantComments->size() = 1) with log ('There can be no more than one comments for an association.');
	comment := relevantComments->any(true);
}

mapping notation::Edge::edgeToRegularAssociation(allEdges : OrderedSet(Edge)) : cls::Association
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Association)
	}
{
	var association := self.element.oclAsType(uml::Association);
	assert error (association.memberEnd->size() = 2) with log('Could not transform association because there are not exactly two association ends.', association);
	
	referencedElement := association;
	aggregationKind := association.memberEnd->at(1).aggregation.convert();
	left := new UMLTypeReference(association.memberEnd->at(1).type);
	right := new UMLTypeReference(association.memberEnd->at(2).type);
	
	properties := association.map edgeToAssociationProperties(false);
}

mapping uml::Association::edgeToAssociationProperties(inverted : Boolean) : cls::AssociationProperties {
	assert error (self.memberEnd->size() = 2) with log('Could not transform association because there are not exactly two association ends.', self);
		
	var left := self.memberEnd->at(if inverted then 2 else 1 endif);
	var right := self.memberEnd->at(if inverted then 1 else 2 endif);
	
	cardinalityLeft := left.map multiplicityElementToCardinality();
	cardinalityRight := right.map multiplicityElementToCardinality();

	//TODO reading direction not considered yet
}


mapping uml::MultiplicityElement::multiplicityElementToCardinality() : cls::Cardinality {
	lowerBound := self.lower;
	upperBound := self.upper;
}



mapping uml::Classifier::classifierToTypeReference(_ : String) : cls::UMLTypeReference {
	type := self
}

mapping notation::Node::nodeToCommentConnector() : cls::CommentLink
	when {
		self.element.oclIsKindOf(uml::Comment) and
		self.element.oclAsType(uml::Comment).annotatedElement->forAll(not oclIsKindOf(uml::Association) and oclIsKindOf(uml::Classifier))
	}
{
	var commentElement := self.element.oclAsType(uml::Comment);
	assert error (commentElement.annotatedElement->size() = 1) with log ("Comments must not comment more than one element.", commentElement);
	
	left := new UMLTypeReference(commentElement.annotatedElement->any(true).oclAsType(uml::Classifier));
	comment := comment;
}

query notation::Edge::findEdgeComments(allEdges : OrderedSet(notation::Edge)) : OrderedSet(uml::Comment) {
	return
		allEdges->select(source = self and target.element.oclIsKindOf(uml::Comment))->collect(target.element.oclAsType(uml::Comment))
		->union(
		allEdges->select(target = self and source.element.oclIsKindOf(uml::Comment))->collect(source.element.oclAsType(uml::Comment))
		)->asOrderedSet();
}

query uml::PrimitiveType::convert() : cls::PrimitiveType {
	switch {
		case (self.name = "Real") {return cls::PrimitiveType::DOUBLE}
		case (self.name = "EDouble") {return cls::PrimitiveType::DOUBLE}
		case (self.name = "Integer") {return cls::PrimitiveType::INT}
		case (self.name = "EInt") {return cls::PrimitiveType::INT}
		case (self.name = "Boolean") {return cls::PrimitiveType::BOOLEAN}
		case (self.name = "EBoolean") {return cls::PrimitiveType::BOOLEAN}
		case (self.name = "EByte") {return cls::PrimitiveType::BYTE}
		case (self.name = "EChar") {return cls::PrimitiveType::CHAR}
		case (self.name = "EFloat") {return cls::PrimitiveType::FLOAT}
		case (self.name = "ELong") {return cls::PrimitiveType::LONG}
		case (self.name = "EShort") {return cls::PrimitiveType::SHORT}
		case (self.name = "String") {return cls::PrimitiveType::STRING}
		case (self.name = "EString") {return cls::PrimitiveType::STRING}
	};
	assert error (false) with log('Could not convert primitive UML type.', self);
	return null;
}

query uml::VisibilityKind::covert() : cls::Visibility {
	switch {
		case(self = uml::VisibilityKind::public) {return cls::Visibility::PUBLIC}
		case(self = uml::VisibilityKind::private) {return cls::Visibility::PRIVATE}
		case(self = uml::VisibilityKind::protected) {return cls::Visibility::PROTECTED}
		case(self = uml::VisibilityKind::package) {return cls::Visibility::PACKAGE}
	};
	assert error (false) with log('Could not convert UML visibility type.', self);
	return null;
}

query uml::AggregationKind::convert() : cls::AggregationKind {
	switch {
		case(self = uml::AggregationKind::none) {return cls::AggregationKind::NONE}
		case(self = uml::AggregationKind::shared) {return cls::AggregationKind::AGGREGATION}
		case(self = uml::AggregationKind::composite) {return cls::AggregationKind::COMPOSITION}
	};
	assert error (false) with log('Could not convert UML aggregation kind.', self);
	return null;
}
