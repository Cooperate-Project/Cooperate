import TransformationUtils_Class;

transformation Textual_to_Graphical_for_Class(in textual : TXT, inout graphical : NOTATION, in umlmodel : UML, in umlprimitives : UML);

modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype TXT uses cls('http://www.cooperateproject.de/modeling/textual/cls/Cls');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype STYLE uses style('http://www.eclipse.org/papyrus/infra/viewpoints/policy/style');

main() {
	var diagrams := textual.rootObjects()[cls::ClassDiagram];
	assert fatal (diagrams->size() = 1);
	diagrams->map diagramToDiagram();
}

mapping cls::ClassDiagram::diagramToDiagram() : notation::Diagram {
	type := "PapyrusUMLClassDiagram";
	name := self.title;
	measurementUnit := notation::MeasurementUnit::Pixel;
	
	var umlRootElement := self.rootPackage.referencedElement.oclAsType(uml::Package);
	element := umlRootElement.toEObject();
	var allConnectors := self.getAllTransitiveConnectors();
	var allPackages := self.getAllTransitivePackages();
	
	children += self.rootPackage.packages->map packageToShape();
	children += self.rootPackage.classifiers->map classifierToShape();
	children += allConnectors->selectByKind(cls::MultiAssociation)->map multiAssociationToShape(); // all nested in root
	children += self.rootPackage.connectors->select(isCommented())->selectByKind(cls::Commentable)->map commentLinkToShape();
	
	edges += allConnectors->select(not oclIsKindOf(cls::CommentLink))->map connectorToConnector();
	edges += allConnectors->selectByKind(cls::MultiAssociation).connectorEnds->map connectorEndToEdge();
	edges += allConnectors->select(isCommented())->selectByKind(cls::Commentable)->map commentableToEdge();
	edges += allPackages->collect(packageImports)->map packageImportToEdge();
	
	styles += self.map stringValueStyle();
	styles += self.map diagramStyle();
	styles += self.map papyrusViewStyle(umlRootElement);
}

mapping cls::Package::packageToShape() : notation::Shape
{
	type := self.getNestedName(PAPYRUS_NOTATION_SHAPE_PACKAGE_REGULAR);
	element := self.referencedElement.toEObject();
	
	children += self.map nameDecorationPackage();
	children += self.map packageToCompartment();
	
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping cls::Package::packageToCompartment() : notation::BasicCompartment
{
	type := self.getNestedName(PAPYRUS_NOTATION_COMPARTMENT_PACKAGE_PACKAGEABLE_REGULAR);
	styles += result.toEObject().map titleStyle();
	layoutConstraint := result.toEObject().map notationBounds();
	
	children += self.packages->map packageToShape();
	children += self.classifiers->map classifierToShape();
	children += self.connectors->select(isCommented())->selectByKind(cls::Commentable)->map commentLinkToShape();
}



// classifiers

mapping cls::Classifier::classifierToShape() : notation::Shape
merges cls::Classifier::classToShape, cls::Classifier::interfaceToShape
{
	element := self.referencedElement.oclAsType(ecore::EObject);
	
	children += self.map classifierToNameDecorationNode();
	children += self.map classifierToFloatingLabelDecorationNode();
	
	children += self.map classifierToAttributesCompartment();
	children += self.map classifierToOperationsCompartment();
	children += self.map classifierToSignalsCompartment();
	
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping cls::Classifier::interfaceToShape() : notation::Shape
when {self.oclIsKindOf(cls::Interface)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_SHAPE_INTERFACE_REGULAR);
}

mapping cls::Classifier::classToShape() : notation::Shape
when {self.oclIsKindOf(cls::Class)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_SHAPE_CLASS_REGULAR);
}

mapping cls::Commentable::commentLinkToShape() : notation::Shape
{
	type := self.getNestedName(PAPYRUS_NOTATION_SHAPE_COMMENT_REGULAR);
	element := self.comment.toEObject();
	children += self.map commentLabelBodyHintDecoration();
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping cls::MultiAssociation::multiAssociationToShape() : notation::Shape
{
	type := PAPYRUS_NOTATION_SHAPE_NARY_REGULAR;
	element := self.referencedElement.toEObject();
	layoutConstraint := result.toEObject().map locationConstraint();
	children += self.map multiAssociationToFloatingLabelDecorationNode();
}

mapping cls::Classifier::classifierToAttributesCompartment() : notation::BasicCompartment
merges cls::Classifier::classToAttributesCompartment, cls::Classifier::interfaceToAttributesCompartment
{
	children += self.members->select(oclIsKindOf(cls::Attribute))->oclAsType(cls::Attribute)->map attributeToShape();
	styles += result.toEObject().map titleStyle();
	styles += result.toEObject().map sortingStyle();
	styles += result.toEObject().map filteringStyle();
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping cls::Classifier::classToAttributesCompartment() : notation::BasicCompartment
when {self.oclIsKindOf(cls::Class)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_COMPARTMENT_CLASS_PROPERTIES_REGULAR);
}

mapping cls::Classifier::interfaceToAttributesCompartment() : notation::BasicCompartment
when {self.oclIsKindOf(cls::Interface)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_PROPERTIES_REGULAR);
}

mapping cls::Attribute::attributeToShape() : notation::Shape
merges cls::Attribute::classAttributeToShape, cls::Attribute::interfaceAttributeToShape
{
	element := self.referencedElement.oclAsType(ecore::EObject);
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Attribute::classAttributeToShape() : notation::Shape
when {self.owner.oclIsKindOf(cls::Class)}
{	
	type := PAPYRUS_NOTATION_SHAPE_CLASS_ATTRIBUTE;
}

mapping cls::Attribute::interfaceAttributeToShape() : notation::Shape
when {self.owner.oclIsKindOf(cls::Interface)}
{	
	type := PAPYRUS_NOTATION_SHAPE_INTERFACE_ATTRIBUTE;
}

mapping cls::Classifier::classifierToOperationsCompartment() : notation::BasicCompartment
merges cls::Classifier::classToOperationsCompartment, cls::Classifier::interfaceToOperationsCompartment
{
	children += self.members->select(oclIsKindOf(cls::Method))->oclAsType(cls::Method)->map methodToShape();
	styles += result.toEObject().map titleStyle();
	styles += result.toEObject().map sortingStyle();
	styles += result.toEObject().map filteringStyle();
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping cls::Classifier::classToOperationsCompartment() : notation::BasicCompartment
when {self.oclIsKindOf(cls::Class)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_COMPARTMENT_CLASS_OPERATIONS_REGULAR);
}

mapping cls::Classifier::interfaceToOperationsCompartment() : notation::BasicCompartment
when {self.oclIsKindOf(cls::Interface)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_OPERATIONS_REGULAR);
}

mapping cls::Method::methodToShape() : notation::Shape
merges cls::Method::classMethodToShape, cls::Method::interfaceMethodToShape
{
	element := self.referencedElement.oclAsType(ecore::EObject);
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Method::classMethodToShape() : notation::Shape
when {self.owner.oclIsKindOf(cls::Class)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_SHAPE_CLASS_OPERATION);
}

mapping cls::Method::interfaceMethodToShape() : notation::Shape
when {self.owner.oclIsKindOf(cls::Interface)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_SHAPE_INTERFACE_OPERATION);
}

mapping cls::Classifier::classifierToSignalsCompartment() : notation::BasicCompartment
merges cls::Classifier::classToSignalsCompartment, cls::Classifier::interfaceToSignalsCompartment
{
	styles += result.toEObject().map titleStyle();
	styles += result.toEObject().map sortingStyle();
	styles += result.toEObject().map filteringStyle();
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping cls::Classifier::classToSignalsCompartment() : notation::BasicCompartment
when {self.oclIsKindOf(cls::Class)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_COMPARTMENT_CLASS_NESTED_REGULAR);
}

mapping cls::Classifier::interfaceToSignalsCompartment() : notation::BasicCompartment
when {self.oclIsKindOf(cls::Interface)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_NESTED_REGULAR);
}



mapping cls::Classifier::classifierToNameDecorationNode() : notation::DecorationNode
merges cls::Classifier::classToNameDecorationNode, cls::Classifier::interfaceToNameDecorationNode
{
}

mapping cls::Classifier::classToNameDecorationNode() : notation::DecorationNode
when{self.oclIsKindOf(cls::Class)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_NODE_CLASS_NAME_REGULAR);
}

mapping cls::Classifier::interfaceToNameDecorationNode() : notation::DecorationNode
when{self.oclIsKindOf(cls::Interface)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_NODE_INTERFACE_NAME_REGULAR);
}

mapping cls::Classifier::classifierToFloatingLabelDecorationNode() : notation::DecorationNode
merges cls::Classifier::classToFloatingLabelDecorationNode, cls::Classifier::interfaceToFloatingLabelDecorationNode
{
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Classifier::classToFloatingLabelDecorationNode() : notation::DecorationNode
when {self.oclIsKindOf(cls::Class)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_NODE_CLASS_FLOATINGLABEL_REGULAR);
}

mapping cls::Classifier::interfaceToFloatingLabelDecorationNode() : notation::DecorationNode
when {self.oclIsKindOf(cls::Interface)}
{
	type := self.getNestedName(PAPYRUS_NOTATION_NODE_INTERFACE_FLOATINGLABEL_REGULAR);
}


// connectors

mapping cls::Connector::connectorToConnector() : notation::Connector
disjuncts cls::Association::connectorToEdge, cls::Generalization::generalizationToEdge, cls::Implementation::implementationToEdge
{
}

mapping cls::Association::connectorToEdge() : notation::Connector
when { self.oclIsKindOf(cls::Association) }
{
	type := PAPYRUS_NOTATION_EDGE_ASSOCIATION;
	
	source := self.left.oclAsType(UMLTypeReference).type.typeToView();
	target := self.right.oclAsType(UMLTypeReference).type.typeToView();
	element := self.referencedElement.toEObject();

	children += self.map stereotypeDecorationAssocation();
	children += self.map nameDecorationAssociation();
	children += self.properties.map targetRoleDecoration();
	children += self.properties.map sourceRoleDecoration();
	children += self.properties.map sourceMultiplicityDecoration();
	children += self.properties.map targetMultiplicityDecoration();
	
	bendpoints := result.map connectorToBendpoint();
	styles += result.toEObject().map fontStyle();
}

mapping cls::Generalization::generalizationToEdge() : notation::Connector
when { self.oclIsKindOf(cls::Generalization) }
{
	type := PAPYRUS_NOTATION_EDGE_GENERALIZATION;
	
	var specialClassifier := self.left.oclAsType(UMLTypeReference).type.oclAsType(uml::Classifier);
	var generalClassifier := self.right.oclAsType(UMLTypeReference).type.oclAsType(uml::Classifier);
	
	source := specialClassifier.typeToView();
	target := generalClassifier.typeToView();
	element := specialClassifier.generalization->any(specific = specialClassifier).toEObject();
	
	children += self.map stereotypeDecorationGeneralization();
	
	bendpoints := result.map connectorToBendpoint();
	styles += result.toEObject().map fontStyle();
}

mapping cls::Implementation::implementationToEdge() : notation::Connector
when { self.oclIsKindOf(cls::Implementation) }
{
	type := PAPYRUS_NOTATION_EDGE_IMPLEMENTATION;
	
	var implementingClassifier := self.left.oclAsType(UMLTypeReference).type.oclAsType(uml::BehavioredClassifier);
	var implementedInterface := self.right.oclAsType(UMLTypeReference).type.oclAsType(uml::Classifier);
	
	source := implementingClassifier.typeToView();
	target := implementedInterface.typeToView();
	
	element := implementingClassifier.interfaceRealization->any(contract = implementedInterface).toEObject();
	
	children += self.map stereotypeDecorationImplementation();
	children += self.map nameDecorationImplementation();
	
	bendpoints := result.map connectorToBendpoint();
	styles += result.toEObject().map fontStyle();
}

mapping cls::MemberEnd::connectorEndToEdge() : notation::Connector
{
	type := PAPYRUS_NOTATION_EDGE_ASSOCIATIONBRANCH;
	
	var umlAssociation := self.association.referencedElement;
	element := umlAssociation.toEObject();

	var associationDiamondShape := resolveoneIn(cls::MultiAssociation::multiAssociationToShape, s : notation::Shape | s.element = umlAssociation.toEObject());
	assert error (associationDiamondShape != null) with log('Could not find the association diamond for a n-ary association.', umlAssociation);
	source := associationDiamondShape;
	
	var referencedNotationElement := self.type.type.typeToView();
	assert error (referencedNotationElement != null) with log('Could not find the referenced view for a UML type.', self.type);
	target := referencedNotationElement;

	children += self.map targetRoleDecorationMemberEnd();
	children += self.map targetMultiplicityDecorationMemberEnd();

	bendpoints := result.map connectorToBendpoint();
	styles += result.toEObject().map fontStyle();
	styles += self.map semanticBranchStyle();
}

mapping cls::Commentable::commentableToEdge() : notation::Connector
{
	type := PAPYRUS_NOTATION_EDGE_COMMENTLINK;
	
	var commentShape := self.resolveoneIn(cls::Commentable::commentLinkToShape);
	var classifier := self.getCommentedElement().oclAsType(uml::Classifier);
	
	source := commentShape;
	target := classifier.typeToView();
	element := null;
	
	bendpoints := result.map connectorToBendpoint();
	styles += result.toEObject().map fontStyle();
}

mapping cls::PackageImport::packageImportToEdge() : notation::Connector
{
	var umlPackageImport := self.referencedElement;

	type := PAPYRUS_NOTATION_EDGE_PACKAGEIMPORT;
	element := umlPackageImport.toEObject();
	source := umlPackageImport.importingNamespace.oclAsType(uml::Package).packageToShape();
	target := umlPackageImport.importedPackage.packageToShape();
	
	children += self.map stereotypeDecorationPackageImport();
	
	bendpoints := result.map connectorToBendpoint();
	styles += result.toEObject().map fontStyle();
}

mapping notation::Connector::connectorToBendpoint() : notation::RelativeBendpoints
{
}


// decoration nodes

/*
5038 Comment Label Body Hint
6001 Stereotype (Association)
6002 Name (Association)
6003 TargetRole (Association)
6005 SourceRole (Association)
6007 Stereotype (Generalization)
6008 Stereotype (Interface Realization)
6009 Name (Interface Realization)
6024 TargetRole (AssociationBranch)
6033 SourceMultiplicity
6034 TargetMultiplicity
6035 TargetMultiplicity (AssociationBranch)
8521 Floating Label (Association Diamond)
*/

mapping cls::Commentable::commentLabelBodyHintDecoration() : notation::DecorationNode
{
	type := self.getNestedName(PAPYRUS_NOTATION_NODE_COMMENT_BODY_REGULAR);
}

mapping cls::Association::stereotypeDecorationAssocation() : notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATION_STEREOTYPE;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Association::nameDecorationAssociation() : notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATION_NAME;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Package::nameDecorationPackage() : notation::DecorationNode
{
	type := self.getNestedName(PAPYRUS_NOTATION_NODE_PACKAGE_NAME_REGULAR);
}

mapping cls::AssociationProperties::targetRoleDecoration() : notation::DecorationNode
when {self.propertyRight != null}
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATION_TARGETROLE;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::AssociationProperties::sourceRoleDecoration() : notation::DecorationNode
when {self.propertyLeft != null}
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATION_SOURCEROLE;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Generalization::stereotypeDecorationGeneralization() : notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_GENERALIZATION_STEREOTYPE;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Implementation::stereotypeDecorationImplementation() : notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_INTERFACEREALIZATION_STEREOTYPE;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::Implementation::nameDecorationImplementation() : notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_INTERFACEREALIZATION_NAME;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::MemberEnd::targetRoleDecorationMemberEnd() : notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATIONBRANCH_ROLENAME;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::AssociationProperties::sourceMultiplicityDecoration() : notation::DecorationNode
when {self.cardinalityLeft != null}
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATION_SOURCEMULTIPLICITY;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::AssociationProperties::targetMultiplicityDecoration() : notation::DecorationNode
when {self.cardinalityRight != null}
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATION_TARGETMULTIPLICITY;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::MemberEnd::targetMultiplicityDecorationMemberEnd() : notation::DecorationNode
when {self.cardinality != null}
{
	type := PAPYRUS_NOTATION_NODE_ASSOCIATIONBRANCH_MULTIPLICITY;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::MultiAssociation::multiAssociationToFloatingLabelDecorationNode(): notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_NARY_NAME;
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping cls::PackageImport::stereotypeDecorationPackageImport() : notation::DecorationNode
{
	type := PAPYRUS_NOTATION_NODE_PACKAGEIMPORT_STEREOTYPE;
	layoutConstraint := result.toEObject().map locationConstraint();
}

// style stuff

mapping ecore::EObject::locationConstraint() : notation::Location
{
}

mapping ecore::EObject::titleStyle() : notation::TitleStyle
{
}

mapping ecore::EObject::sortingStyle() : notation::SortingStyle
{
}

mapping ecore::EObject::filteringStyle() : notation::FilteringStyle
{
}

mapping ecore::EObject::notationBounds() : notation::Bounds
{
}

mapping ecore::EObject::fontStyle() : notation::FontStyle
{
}

mapping cls::ClassDiagram::stringValueStyle() : notation::StringValueStyle
{
	name := "diagram_compatibility_version";
	stringValue := "1.2.0";	
}

mapping cls::ClassDiagram::diagramStyle() : notation::DiagramStyle
{	
}

mapping cls::ClassDiagram::papyrusViewStyle(rootElement : uml::Package) : style::PapyrusViewStyle
{
	owner := rootElement.toEObject();
}

mapping cls::MemberEnd::semanticBranchStyle() : notation::EObjectValueStyle
{
	name := "Semantic_Branch_Style";
	eObjectValue := self.determineProperty().toEObject();
}

query cls::MemberEnd::determineProperty() : uml::Property
{
	var umlAssociation := self.association.referencedElement.oclAsType(uml::Association);
	var referencedProperty := self.referencedElement;
	
	var candidates := umlAssociation.memberEnd->select(p | p.matches(self));
	return if candidates->size() = 1 then candidates->any(true) else referencedProperty.oclAsType(uml::Property) endif;
}

query uml::Property::matches(memberEnd : cls::MemberEnd) : Boolean
{
	return
		memberEnd.referencedElement = self or
		(
			self.type = memberEnd.type.type and
			(
				memberEnd.cardinality = null or
				self.matches(memberEnd.cardinality)
			)
		);
}

query uml::MultiplicityElement::matches(cardinality : cls::Cardinality) : Boolean
{
	return
		self.lower = cardinality.lowerBound and
		(
			self.upper = cardinality.upperBound or
			(cardinality.upperBound = -1 and self.upper = *) 
		);
}

// helpers

query OclAny::toEObject() : ecore::EObject {
	return self.oclAsType(ecore::EObject);
}

query uml::Type::typeToView() : notation::View
{
	return if self.oclIsKindOf(uml::Association) then self.typeToEdge() else self.typeToShape() endif;
}

query uml::Type::typeToShape() : notation::Shape
{
	return resolveoneIn(cls::Classifier::classifierToShape, s : notation::Shape | s.element = self.toEObject());
}

query uml::Type::typeToEdge() : notation::Edge
{
	return resolveoneIn(cls::Connector::connectorToConnector, e : notation::Edge | e.element = self.toEObject());
}

query uml::Package::packageToShape() : notation::Shape
{
	return resolveoneIn(cls::Package::packageToShape, s : notation::Shape | s.element = self.toEObject());
}

query cls::Connector::isCommentable() : Boolean
{
	return self.oclIsKindOf(cls::Commentable);
}

query cls::Connector::isCommented() : Boolean
{
	return self.isCommentable() and self.oclAsType(cls::Commentable).comment != null;
}

query cls::Element::isNested() : Boolean
{
	var owningPackage := if self.getNearestPackage() = self then self.getNearestPackage().owningPackage else self.getNearestPackage() endif;
	var owningPackage2 := owningPackage.owningPackage;
	return owningPackage != null and owningPackage2 != null;
}

query cls::Element::getNestedName(type : String) : String
{
	return if self.isNested() then type + "_CN" else type endif;
}