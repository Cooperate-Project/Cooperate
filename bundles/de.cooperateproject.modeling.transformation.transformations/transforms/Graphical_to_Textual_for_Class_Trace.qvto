import TraceUtils_Class;

transformation Graphical_to_Textual_for_Class_Trace(in graphicalTrace : TRACE, out textualTrace : TRACE, in textualModel : TEXTUAL, in t2gTransformation : QVTO);

modeltype QVTO uses qvtoperational('http://www.eclipse.org/QVT/1.0.0/Operational');
modeltype TRACE uses trace('http:///www.eclipse.org/m2m/qvt/operational/trace.ecore');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype TEXTUAL uses cls('http://www.cooperateproject.de/modeling/textual/cls/Cls');
modeltype GRAPHICAL uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype STYLE uses style('http://www.eclipse.org/papyrus/infra/viewpoints/policy/style');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');

main() {
	var traces := graphicalTrace.rootObjects()[trace::Trace];
	assert fatal (traces->size() = 1);
	traces->initializeProperties();
	traces->map trace();
}

helper trace::Trace::initializeProperties() {
	TARGET_TRANSFORMATION_NAME := "Textual_to_Graphical_for_Class";
	TARGET_TRANSFORMATION := t2gTransformation.rootObjects()[qvtoperational::expressions::OperationalTransformation]->any(true);
}

mapping trace::Trace::trace() : trace::Trace
{
	traceRecords += self.traceRecords->map traceRecord()->flatten();
}

mapping trace::TraceRecord::traceRecord() : List(trace::TraceRecord)
{
	result += self.map traceRecordExtended();
}



mapping trace::TraceRecord::traceRecordExtended() : List(trace::TraceRecord)
{
	result += self.map traceRecordExtendedDiagram();
	result += self.map traceRecordExtendedPackageShape();
	result += self.map traceRecordExtendedClassifier();
	result += self.map traceRecordExtendedAttributeShape();
	result += self.map traceRecordExtendedOperationShape();
	result += self.map traceRecordExtendedClassShape();
	result += self.map traceRecordExtendedInterfaceShape();
	result += self.map traceRecordExtendedConnector();
	result += self.map traceRecordExtendedConnectorToEdge();
	result += self.map traceRecordExtendedGeneralizationToEdge();
	result += self.map traceRecordExtendedImplementationToEdge();
	result += self.map traceRecordExtendedCommentLinkToEdge();
	result += self.map traceRecordExtendedCommentableToEdge2();
	result += self.map traceRecordExtendedMultiAssociation();
	result += self.map traceRecordExtendedMemberEndEdge();
	result += self.map traceRecordExtendedPackageImportEdge();
}

mapping trace::TraceRecord::traceRecordExtendedDiagram() : List(trace::TraceRecord)
when {self.mappingOperation.name = "diagramToDiagram"}
{
	var classDiagram := self.getResult().modelElement;
	var notationDiagram := self.getSelf().modelElement.oclAsType(notation::Diagram);

	result += new TraceRecord("diagramToDiagram", "ClassDiagram", classDiagram, "Diagram", notationDiagram.eobject());
	result += new TraceRecord("stringValueStyle", "ClassDiagram", classDiagram, "StringValueStyle", notationDiagram.styles->any(oclIsKindOf(notation::StringValueStyle)).eobject());
	result += new TraceRecord("diagramStyle", "ClassDiagram", classDiagram, "DiagramStyle", notationDiagram.styles->any(oclIsKindOf(notation::DiagramStyle)).eobject());
	var viewStyleRecord := new TraceRecord("papyrusViewStyle", "ClassDiagram", classDiagram, "PapyrusViewStyle", notationDiagram.styles->any(oclIsKindOf(style::PapyrusViewStyle)).eobject());
	viewStyleRecord.parameters.parameters += object VarParameterValue {
		name := "rootElement";
		type := "Package";
		value := new EValue(notationDiagram.element);
	};
	result += viewStyleRecord;
}

mapping trace::TraceRecord::traceRecordExtendedPackageShape() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToPackage"}
{
	var package := self.getResult().modelElement;
	var shape := self.getSelf().modelElement.oclAsType(notation::Shape);
	
	result += new TraceRecord("packageToShape", "Package", package, "Shape", shape.eobject());
	result += new TraceRecord("nameDecorationPackage", "Package", package, "DecorationNode", shape.children->any(matches(PAPYRUS_NOTATION_NODE_PACKAGE_NAME_REGULAR)).eobject());
	result += shape.map traceRecordExtended_notationBounds();
	
	var compartment := shape.children->any(matches(PAPYRUS_NOTATION_COMPARTMENT_PACKAGE_PACKAGEABLE_REGULAR)).oclAsType(notation::BasicCompartment);
	result += new TraceRecord("packageToCompartment", "Package", package, "BasicCompartment", compartment.eobject());
	result += new TraceRecord("titleStyle", "EObject", compartment.eobject(), "TitleStyle", compartment.styles->selectByKind(notation::TitleStyle)->any(true).eobject());
	result += compartment.map traceRecordExtended_notationBounds();
}

query View::matches(type : String) : Boolean
{
	return self.type = type or self.type = type + "_CN";
}

mapping trace::TraceRecord::traceRecordExtendedAttributeShape() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToProperty"}
{
	result += new TraceRecord("attributeToShape", "Attribute", self.getResult().modelElement.eobject(), "Shape", self.getSelfNode().eobject());
	result += self.map traceRecordExtendedAttributeShape_Class();
	result += self.map traceRecordExtendedAttributeShape_Interface();
	result += self.getSelfNode().map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedAttributeShape_Class() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclAsType(cls::Attribute).owner.oclIsKindOf(cls::Class)}
{
	result += new TraceRecord("classAttributeToShape", "Attribute", self.getResult().modelElement.eobject(), "Shape", self.getSelfNode().eobject());
}

mapping trace::TraceRecord::traceRecordExtendedAttributeShape_Interface() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclAsType(cls::Attribute).owner.oclIsKindOf(cls::Interface)}
{
	result += new TraceRecord("interfaceAttributeToShape", "Attribute", self.getResult().modelElement.eobject(), "Shape", self.getSelfNode().eobject());
}

mapping trace::TraceRecord::traceRecordExtendedOperationShape() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToOperation"}
{
	result += new TraceRecord("methodToShape", "Method", self.getResult().modelElement.eobject(), "Shape", self.getSelfNode().eobject());
	result += self.map traceRecordExtendedOperationShape_Class();
	result += self.map traceRecordExtendedOperationShape_Interface();
	result += self.getSelfNode().map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedOperationShape_Class() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclAsType(cls::Method).owner.oclIsKindOf(cls::Class)}
{
	result += new TraceRecord("classMethodToShape", "Method", self.getResult().modelElement.eobject(), "Shape", self.getSelfNode().eobject());
}

mapping trace::TraceRecord::traceRecordExtendedOperationShape_Interface() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclAsType(cls::Method).owner.oclIsKindOf(cls::Interface)}
{
	result += new TraceRecord("interfaceMethodToShape", "Method", self.getResult().modelElement.eobject(), "Shape", self.getSelfNode().eobject());
}

mapping trace::TraceRecord::traceRecordExtendedClassShape() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToClass"}
{
	var clz := self.getResult().modelElement;
	var shape := self.getSelfNode().eobject();
	result += new TraceRecord("classToShape", "Classifier", clz, "Shape", shape);
}

mapping trace::TraceRecord::traceRecordExtendedInterfaceShape() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToInterface"}
{
	var interface := self.getResult().modelElement;
	var shape := self.getSelfNode().eobject();
	result += new TraceRecord("interfaceToShape", "Classifier", interface, "Shape", shape);
}

mapping trace::TraceRecord::traceRecordExtendedClassifier() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToClassifier"}
{
	result += new TraceRecord("classifierToShape", "Classifier", self.getResult().modelElement.eobject(), "Shape", self.getSelfNode().eobject());
	result += self.map traceRecordExtendedClassifier_UnknownDecorationNode();
	result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNode();
	result += self.getSelfNode().map traceRecordExtended_notationBounds();
	result += self.map traceRecordExtendedClassifier_classifierToAttributesCompartment();
	result += self.map traceRecordExtendedClassifier_classifierToOperationsCompartment();
	result += self.map traceRecordExtendedClassifier_classifierToSignalsCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_UnknownDecorationNode() : List(trace::TraceRecord)
{
	result += self.map traceRecordExtendedClassifier_UnknownDecorationNodeClass();
	result += self.map traceRecordExtendedClassifier_UnknownDecorationNodeInterface();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_UnknownDecorationNodeClass() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Class)}
{
	result += new TraceRecord("classifierToNameDecorationNode", "Classifier", self.getResult().modelElement, "DecorationNode", self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_NODE_CLASS_NAME_REGULAR)).eobject());
	result += new TraceRecord("classToNameDecorationNode", "Classifier", self.getResult().modelElement, "DecorationNode", self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_NODE_CLASS_NAME_REGULAR)).eobject());
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_UnknownDecorationNodeInterface() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Interface)}
{
	result += new TraceRecord("classifierToNameDecorationNode", "Classifier", self.getResult().modelElement, "DecorationNode", self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_NODE_INTERFACE_NAME_REGULAR)).eobject());
	result += new TraceRecord("interfaceToNameDecorationNode", "Classifier", self.getResult().modelElement, "DecorationNode", self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_NODE_INTERFACE_NAME_REGULAR)).eobject());
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_FloatingLabelDecorationNode() : List(trace::TraceRecord)
{
	result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeClass();
	result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeInterface();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_FloatingLabelDecorationNodeClass() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Class)}
{
	var classifier := self.getResult().modelElement;
	var node := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_NODE_CLASS_FLOATINGLABEL_REGULAR));
	result += new TraceRecord("classifierToFloatingLabelDecorationNode", "Classifier", classifier, "DecorationNode", node.eobject());
	result += new TraceRecord("classToFloatingLabelDecorationNode", "Classifier", classifier, "DecorationNode", node.eobject());
	result += node.map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_FloatingLabelDecorationNodeInterface() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Interface)}
{
	var classifier := self.getResult().modelElement;
	var node := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_NODE_INTERFACE_FLOATINGLABEL_REGULAR));
	result += new TraceRecord("classifierToFloatingLabelDecorationNode", "Classifier", classifier, "DecorationNode", node.eobject());
	result += new TraceRecord("interfaceToFloatingLabelDecorationNode", "Classifier", classifier, "DecorationNode", node.eobject());
	result += node.map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_classifierToAttributesCompartment() : List(trace::TraceRecord)
{
	result += self.map traceRecordExtendedClassifier_classToAttributesCompartment();
	result += self.map traceRecordExtendedClassifier_interfaceToAttributesCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_classToAttributesCompartment() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Class)}
{
	var classifier := self.getResult().modelElement;
	var compartment := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_COMPARTMENT_CLASS_PROPERTIES_REGULAR)).eobject();
	result += new TraceRecord("classifierToAttributesCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += new TraceRecord("classToAttributesCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtendedClassifier_basicCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_interfaceToAttributesCompartment() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Interface)}
{
	var classifier := self.getResult().modelElement;
	var compartment := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_PROPERTIES_REGULAR)).eobject();
	result += new TraceRecord("classifierToAttributesCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += new TraceRecord("interfaceToAttributesCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtendedClassifier_basicCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_classifierToOperationsCompartment() : List(trace::TraceRecord)
{
	result += self.map traceRecordExtendedClassifier_classToOperationsCompartment();
	result += self.map traceRecordExtendedClassifier_interfaceToOperationsCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_classToOperationsCompartment() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Class)}
{
	var classifier := self.getResult().modelElement;
	var compartment := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_COMPARTMENT_CLASS_OPERATIONS_REGULAR)).eobject();
	result += new TraceRecord("classifierToOperationsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += new TraceRecord("classToOperationsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtendedClassifier_basicCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_interfaceToOperationsCompartment() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Interface)}
{
	var classifier := self.getResult().modelElement;
	var compartment := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_OPERATIONS_REGULAR)).eobject();
	result += new TraceRecord("classifierToOperationsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += new TraceRecord("interfaceToOperationsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtendedClassifier_basicCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_classifierToSignalsCompartment() : List(trace::TraceRecord)
{
	result += self.map traceRecordExtendedClassifier_classToSignalsCompartment();
	result += self.map traceRecordExtendedClassifier_interfaceToSignalsCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_classToSignalsCompartment() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Class)}
{
	var classifier := self.getResult().modelElement;
	var compartment := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_COMPARTMENT_CLASS_NESTED_REGULAR)).eobject();
	result += new TraceRecord("classifierToSignalsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += new TraceRecord("classToSignalsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtendedClassifier_basicCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedClassifier_interfaceToSignalsCompartment() : List(trace::TraceRecord)
when {self.getResult().modelElement.oclIsKindOf(cls::Interface)}
{
	var classifier := self.getResult().modelElement;
	var compartment := self.getSelfNode().children->any(matches(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_NESTED_REGULAR)).eobject();
	result += new TraceRecord("classifierToSignalsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += new TraceRecord("interfaceToSignalsCompartment", "Classifier", classifier, "BasicCompartment", compartment);
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtendedClassifier_basicCompartment();
}

mapping trace::TraceRecord::traceRecordExtendedConnector() : List(trace::TraceRecord)
when {self.mappingOperation.name = "edgeToConnector" and not self.getResult().modelElement.oclIsKindOf(cls::CommentLink)}
{
	var connector := self.getResult().modelElement;
	var edge := self.getSelf().modelElement;
	result += createEdgeTraceRecord("connectorToConnector", "Connector", connector, "Connector", edge);
}

mapping trace::TraceRecord::traceRecordExtendedConnectorToEdge() : List(trace::TraceRecord)
when {self.mappingOperation.name = "edgeToRegularAssociation"}
{
	var connector := self.getResult().modelElement.oclAsType(cls::Association);
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	
	result += createEdgeTraceRecord("connectorToEdge", "Association", connector.eobject(), "Connector", edge.eobject());
	result += self.map traceRecordExtendedConnectorToEdge_ConnectorBase();
	result += new TraceRecord("stereotypeDecorationAssocation", "Association", connector.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_STEREOTYPE)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_STEREOTYPE)).map traceRecordExtended_locationConstraint();
	result += new TraceRecord("nameDecorationAssociation", "Association", connector.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_NAME)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_NAME)).map traceRecordExtended_locationConstraint();

	result += connector.properties.map traceRecordExtendedConnectorToEdge_AssociationProperties(edge);
}

mapping trace::TraceRecord::traceRecordExtendedConnectorToEdge_ConnectorBase() : List(trace::TraceRecord)
{
	var connector := self.getResult().modelElement.oclAsType(cls::Connector);
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	result += edge.eobject().map traceRecordExtendedConnectorToEdge_ConnectorBase(edge);
}

mapping ecore::EObject::traceRecordExtendedConnectorToEdge_ConnectorBase(edge : notation::Connector) : List(trace::TraceRecord)
{
	result += new TraceRecord("connectorToBendpoint", "Connector", edge.eobject(), "RelativeBendpoints", edge.bendpoints.eobject());
	result += new TraceRecord("fontStyle", "EObject", edge.eobject() , "FontStyle", edge.styles->selectByKind(notation::FontStyle)->any(true).eobject());
}

mapping cls::AssociationProperties::traceRecordExtendedConnectorToEdge_AssociationProperties(edge : notation::Connector) : List(trace::TraceRecord)
{
	result += new TraceRecord("targetRoleDecoration", "AssociationProperties", self.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_TARGETROLE)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_TARGETROLE)).map traceRecordExtended_locationConstraint();
	result += new TraceRecord("sourceRoleDecoration", "AssociationProperties", self.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_SOURCEROLE)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_SOURCEROLE)).map traceRecordExtended_locationConstraint();
	result += new TraceRecord("sourceMultiplicityDecoration", "AssociationProperties", self.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_SOURCEMULTIPLICITY)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_SOURCEMULTIPLICITY)).map traceRecordExtended_locationConstraint();
	result += new TraceRecord("targetMultiplicityDecoration", "AssociationProperties", self.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_TARGETMULTIPLICITY)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATION_TARGETMULTIPLICITY)).map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedGeneralizationToEdge() : List(trace::TraceRecord)
when {self.mappingOperation.name = "edgeToGeneralization"}
{
	var connector := self.getResult().modelElement.oclAsType(cls::Generalization);
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	
	result += createEdgeTraceRecord("generalizationToEdge", "Generalization", connector.eobject(), "Connector", edge.eobject());
	result += self.map traceRecordExtendedConnectorToEdge_ConnectorBase();
	result += new TraceRecord("stereotypeDecorationGeneralization", "Generalization", connector.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_GENERALIZATION_STEREOTYPE)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_GENERALIZATION_STEREOTYPE)).map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedImplementationToEdge() : List(trace::TraceRecord)
when {self.mappingOperation.name = "edgeToImplementation"}
{
	var connector := self.getResult().modelElement.oclAsType(cls::Implementation);
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	
	result += createEdgeTraceRecord("implementationToEdge", "Implementation", connector.eobject(), "Connector", edge.eobject());
	result += self.map traceRecordExtendedConnectorToEdge_ConnectorBase();
	result += new TraceRecord("stereotypeDecorationImplementation", "Implementation", connector.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_INTERFACEREALIZATION_STEREOTYPE)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_INTERFACEREALIZATION_STEREOTYPE)).map traceRecordExtended_locationConstraint();
	result += new TraceRecord("nameDecorationImplementation", "Implementation", connector.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_INTERFACEREALIZATION_NAME)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_INTERFACEREALIZATION_NAME)).map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedCommentableToEdge2() : List(trace::TraceRecord)
when {self.mappingOperation.name = "diagramToDiagram"}
{
	var classDiagram := self.getResult().modelElement.oclAsType(cls::ClassDiagram);
	var notationDiagram := self.getSelf().modelElement.oclAsType(notation::Diagram);

	result += notationDiagram.edges->select(isCommentLinkForAssociation())->selectByKind(notation::Connector)->map commentableToEdge(classDiagram.getAllTransitiveConnectors())->flatten(); 
}


mapping notation::Connector::commentableToEdge(connectors : OrderedSet(cls::Connector)) : List(trace::TraceRecord)
{
	var umlComment := self.source.element.oclAsSet()->union(self.target.element.oclAsSet())->selectByKind(uml::Comment)->any(true);
	var candidateConnectors := connectors->selectByKind(cls::Commentable)->select(comment = umlComment);
	assert error (candidateConnectors->size() = 1) with log('We can only handle comments that are used exactly once.');
	var connector := candidateConnectors->any(true);
	assert error (connector.oclIsKindOf(cls::Connector)) with log ('We only support commentables that are connectors.');
		
	result += createEdgeTraceRecord("commentableToEdge", "Commentable", connector.eobject(), "Connector", self.eobject());
	result += self.eobject().map traceRecordExtendedCommentLinkToEdge_Shape(connector, self);
	result += self.eobject().map traceRecordExtendedConnectorToEdge_ConnectorBase(self);
}


mapping trace::TraceRecord::traceRecordExtendedCommentLinkToEdge() : List(trace::TraceRecord)
when {self.mappingOperation.name = "edgeToCommentLink" and not self.hasCommentLinkForAssociation()}
{
	var connector := self.getResult().modelElement.oclAsType(cls::Commentable);
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);

	result += createEdgeTraceRecord("commentableToEdge", "Commentable", connector.eobject(), "Connector", edge.eobject());
	result += self.map traceRecordExtendedConnectorToEdge_ConnectorBase();
	
	result += self.eobject().map traceRecordExtendedCommentLinkToEdge_Shape(connector, edge);
}

mapping ecore::EObject::traceRecordExtendedCommentLinkToEdge_Shape(connector : cls::Commentable, edge : notation::Connector) : List(trace::TraceRecord)
{
	var commentShape := if edge.source.element = connector.comment.eobject() then edge.source else edge.target endif;
	result += new TraceRecord("commentLinkToShape", "Commentable", connector.eobject(), "Shape", commentShape.eobject());
	result += new TraceRecord("commentLabelBodyHintDecoration", "Commentable", connector.eobject(), "DecorationNode", commentShape.children->any(matches(PAPYRUS_NOTATION_NODE_COMMENT_BODY_REGULAR)).eobject());
	result += commentShape.oclAsType(notation::Node).map traceRecordExtended_notationBounds(); 
}


mapping notation::BasicCompartment::traceRecordExtendedClassifier_basicCompartment() : List(trace::TraceRecord)
{
	result += new TraceRecord("titleStyle", "EObject", self.eobject(), "TitleStyle", self.styles->selectByKind(notation::TitleStyle)->any(true).eobject());
	result += new TraceRecord("sortingStyle", "EObject", self.eobject(), "SortingStyle", self.styles->selectByKind(notation::SortingStyle)->any(true).eobject());
	result += new TraceRecord("filteringStyle", "EObject", self.eobject(), "FilteringStyle", self.styles->selectByKind(notation::FilteringStyle)->any(true).eobject());
	result += self.map traceRecordExtended_notationBounds();
}

mapping notation::Node::traceRecordExtended_locationConstraint() : trace::TraceRecord
{
	init {
		result := new TraceRecord("locationConstraint", "EObject", self.eobject(), "Location", self.layoutConstraint.eobject());
	}
}

mapping notation::Node::traceRecordExtended_notationBounds() : trace::TraceRecord
{
	init {
		result := new TraceRecord("notationBounds", "EObject", self.eobject(), "Bounds", self.layoutConstraint.eobject());
	}
}

mapping trace::TraceRecord::traceRecordExtendedMultiAssociation() : List(trace::TraceRecord)
when {self.mappingOperation.name = "associationNodeToMultiAssociation"}
{
	var association := self.getResult().modelElement.oclAsType(cls::MultiAssociation);
	var node := self.getSelf().modelElement.oclAsType(notation::Shape);

	result += new TraceRecord("multiAssociationToShape", "MultiAssociation", association.eobject(), "Shape", node.eobject());
	result += node.map traceRecordExtended_locationConstraint();
	var floatLabelDecorationNode := node.children->any(matches(PAPYRUS_NOTATION_NODE_NARY_NAME));
	result += new TraceRecord("multiAssociationToFloatingLabelDecorationNode", "MultiAssociation", association.eobject(), "DecorationNode", floatLabelDecorationNode.eobject());
	result += floatLabelDecorationNode.map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedMemberEndEdge() : List(trace::TraceRecord)
when {self.mappingOperation.name = "edgeToMemberEnd"}
{
	var memberEnd := self.getResult().modelElement.oclAsType(cls::MemberEnd);
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	
	result += new TraceRecord("connectorEndToEdge", "MemberEnd", memberEnd.eobject(), "Connector", edge.eobject());
	result += memberEnd.eobject().map traceRecordExtendedConnectorToEdge_ConnectorBase(edge);
	var valueStyle := edge.styles->selectByKind(notation::EObjectValueStyle)->any(name = "Semantic_Branch_Style");
	result += new TraceRecord("semanticBranchStyle", "MemberEnd", memberEnd.eobject(), "EObjectValueStyle", valueStyle.eobject());
	var targetRoleNode := edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATIONBRANCH_ROLENAME));
	result += new TraceRecord("targetRoleDecorationMemberEnd", "MemberEnd", memberEnd.eobject(), "DecorationNode", targetRoleNode.eobject());
	result += targetRoleNode.map traceRecordExtended_locationConstraint();
	var targetMultiNode := edge.children->any(matches(PAPYRUS_NOTATION_NODE_ASSOCIATIONBRANCH_MULTIPLICITY));
	result += new TraceRecord("targetMultiplicityDecorationMemberEnd", "MemberEnd", memberEnd.eobject(), "DecorationNode", targetMultiNode.eobject());
	result += targetMultiNode.map traceRecordExtended_locationConstraint();
}

mapping trace::TraceRecord::traceRecordExtendedPackageImportEdge() : List(trace::TraceRecord)
when {self.mappingOperation.name = "edgeToPackageImport"}
{
	var packageImport := self.getResult().modelElement.oclAsType(cls::PackageImport);
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	
	result += new TraceRecord("packageImportToEdge", "PackageImport", packageImport.eobject(), "Connector", edge.eobject());
	
	result += new TraceRecord("stereotypeDecorationPackageImport", "PackageImport", packageImport.eobject(), "DecorationNode", edge.children->any(matches(PAPYRUS_NOTATION_NODE_PACKAGEIMPORT_STEREOTYPE)).eobject());
	result += edge.children->any(matches(PAPYRUS_NOTATION_NODE_PACKAGEIMPORT_STEREOTYPE)).map traceRecordExtended_locationConstraint();
	result += edge.eobject().map traceRecordExtendedConnectorToEdge_ConnectorBase(edge);
}

// Helpers

query trace::TraceRecord::getSelfNode() : notation::Node {
	assert error (self.getSelf().modelElement.oclIsKindOf(notation::Node)) with log('The contained model element is not a node.');
	return self.getSelf().modelElement.oclAsType(notation::Node);
}

// TODO remove this query
query createEdgeTraceRecord(mappingName : String, contextType : String, contextValue : ecore::EObject, resultType : String, resultValue : ecore::EObject) : trace::TraceRecord
{
	var record := new trace::TraceRecord(mappingName, contextType, contextValue, resultType, resultValue);
	//record.parameters.parameters += new trace::VarParameterValue("classifiers", "Classifier", getAllClassifiers());
	return record;
}

query getAllClassifiers() : OrderedSet(cls::Classifier)
{
	return textualModel.rootObjects()[cls::ClassDiagram]->any(true).getAllTransitiveClassifiers();
}

query trace::TraceRecord::hasCommentLinkForAssociation() : Boolean
{
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	return self.mappingOperation.name = "edgeToCommentLink" and edge.isCommentLinkForAssociation();
}

query notation::Edge::isCommentLinkForAssociation() : Boolean
{
	var referencedElements := self.source.element.oclAsSet()->union(self.target.element.oclAsSet());
	return referencedElements->exists(oclIsKindOf(uml::Association)) and referencedElements->exists(oclIsKindOf(uml::Comment));
}