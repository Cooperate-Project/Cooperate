import TraceUtils_Component;

transformation Graphical_to_Textual_for_Component_Trace(in graphicalTrace : TRACE, out textualTrace : TRACE, in textualModel : TEXTUAL, in t2gTransformation : QVTO);

modeltype QVTO uses qvtoperational('http://www.eclipse.org/QVT/1.0.0/Operational');
modeltype TRACE uses trace('http:///www.eclipse.org/m2m/qvt/operational/trace.ecore');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype TEXTUAL uses cmp('http://www.cooperateproject.de/modeling/textual/component/Component');
modeltype TXTCMN uses textualCommons('http://www.cooperateproject.de/modeling/textual/commons');
modeltype GRAPHICAL uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype STYLE uses style('http://www.eclipse.org/papyrus/infra/gmfdiag/style');

main() {
	var traces := graphicalTrace.rootObjects()[trace::Trace];
	assert fatal (traces->size() = 1);
	traces->initializeProperties();
	traces->map trace();
}

helper trace::Trace::initializeProperties() {
	TARGET_TRANSFORMATION_NAME := "Textual_to_Graphical_for_Component";
	TARGET_TRANSFORMATION := t2gTransformation.rootObjects()[qvtoperational::expressions::OperationalTransformation]->any(true);
}

mapping trace::Trace::trace() : trace::Trace
{
	traceRecords += self.traceRecords->map traceRecord()->flatten();
}

mapping trace::TraceRecord::traceRecord() : List(trace::TraceRecord)
{
	result += self.map traceRecordDiagram();
	//result += self.map traceRecordClassifier();
	//result += self.map traceRecordComponent();
	result += self.map traceRecordClassifier();
	result += self.map nodeToComponent();
	result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeComponent();
	result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeInterface();
	result+= self.map traceRecordClassifier_interfaceToOperationsCompartment();
}





mapping trace::TraceRecord::traceRecordToCopy() :List(trace::TraceRecord) //TODO delete
when {self.mappingOperation.name = "nodeToClassifier"}
{ 
	var component := self.getResult().modelElement;
	var component1 := self.getSelf().modelElement;
	result += new TraceRecord("nodeToComponent", "Component", component1, "Diagram", component.toEObject());
}


mapping trace::TraceRecord::traceRecordClassifier() :List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToClassifier"}
{ 
	var classifier := self.getResult().modelElement;
	var shape := self.getSelf().modelElement;
	result += new TraceRecord("classifiersToShape", "Classifier", classifier, "Shape", shape.toEObject());
	result += self.map traceRecordClassifier_FloatingLabelDecorationNode();


}

/**
mapping trace::TraceRecord::traceRecordComponent() :List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToClassifier"}
{ 
	var classifier := self.getResult().modelElement;
	var shape := self.getSelf().modelElement;
	result += new TraceRecord("classifiersToShape", "Classifier", classifier, "Shape", shape.toEObject());
}**/

mapping trace::TraceRecord::traceRecordClassifier_FloatingLabelDecorationNode() : List(trace::TraceRecord)
{
	//result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeComponent();
	//result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeInterface();
	//result += self.map traceRecordShapeToComponent();
	//result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeInterface();
}
/**
mapping trace::TraceRecord::traceRecordShapeToComponent() :List(trace::TraceRecord) //TODO delete
when {self.getResult().modelElement.oclIsKindOf(cmp::Component)} //Aktuell
{ 
	var component1 := self.getResult().modelElement;
	var component := self.getSelf().modelElement;
	//result += new TraceRecord("classifiersToShape", "Classifier1", component1, "Shape", component.toEObject());
}**/

mapping trace::TraceRecord::nodeToComponent() :List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToComponent" and self.getResult().modelElement.oclIsKindOf(cmp::Component) }{
		//result += self.map traceRecordExtendedClassifier_FloatingLabelDecorationNodeComponent();
		
}
mapping trace::TraceRecord::traceRecordExtendedClassifier_FloatingLabelDecorationNodeComponent() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToComponent"}
{		
var classifier := self.getResult().modelElement;
			var shape :=self.getSelf().modelElement.oclAsType(notation::Shape);
			var node := self.getSelfNode().getChild(PAPYRUS_NOTATION_NODE_COMPONENT_FLOATINGNAME_REGULAR);
			result += new TraceRecord("componentToShape", "Component", classifier, "Shape", shape.eobject());
			var decoration :=self.getSelfNode().getChild(PAPYRUS_NOTATION_NODE_COMPONENT_NAME_REGULAR);
			var compartment := self.getSelfNode().getChild(PAPYRUS_NOTATION_SHAPE_COMPONENT_COMPARTMENT_REGULAR);
			result += new TraceRecord("componentFloatingNameLabel", "Component", classifier, "DecorationNode", node.eobject());
			result += new TraceRecord("componentToNameLabel", "Component", classifier, "DecorationNode", decoration.eobject());
			result += new TraceRecord("componentToCompartment", "Component", classifier, "BasicCompartment", compartment.eobject());
			result += new TraceRecord("titleStyle", "EObject", compartment.eobject(), "TitleStyle", compartment.styles->selectByKind(notation::TitleStyle)->any(true).eobject());
			result += node.map traceRecordExtended_locationConstraint();
			result += compartment.map traceRecordExtended_notationBounds();

					//nested component
	var compartmentNested := self.getSelfNode().getChild(PAPYRUS_NOTATION_SHAPE_COMPONENT_COMPARTMENT_INPACKAGE);	
		result+= self.getSelfNode().map traceRecordExtended_notationBounds();

}



mapping trace::TraceRecord::traceRecordExtendedClassifier_FloatingLabelDecorationNodeInterface() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToInterface"} 
{
	var classifier := self.getResult().modelElement;
	var node := self.getSelfNode().getChild(PAPYRUS_NOTATION_NODE_INTERFACE_FLOATINGNAME_REGULAR);
	var decoration :=self.getSelfNode().getChild(PAPYRUS_NOTATION_NODE_INTERFACE_NAME_REGULAR);
	result += new TraceRecord("interfaceFloatingNameLabel", "Interface", classifier, "DecorationNode", node.eobject());
	result += new TraceRecord("interfaceToNameLabel", "Interface", classifier, "DecorationNode", decoration.eobject());
	result += node.map traceRecordExtended_locationConstraint();
	var compartment := self.getSelfNode().getChild(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_PROPERTIES_REGULAR);
	var shape :=self.getSelf().modelElement.oclAsType(notation::Shape);
	result += new TraceRecord("interfaceToAttributeCompartment", "Interface", classifier, "BasicCompartment", compartment.eobject());
	result += new TraceRecord("interfaceToShape", "Interface", classifier, "Shape", shape.eobject());
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtended_basicCompartment();
	result+= self.getSelfNode().map traceRecordExtended_notationBounds();
}

mapping trace::TraceRecord::traceRecordClassifier_interfaceToOperationsCompartment() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToInterface"}
{
	var classifier := self.getResult().modelElement;
	var compartment := self.getSelfNode().getChild(PAPYRUS_NOTATION_COMPARTMENT_INTERFACE_OPERATIONS_REGULAR).eobject();
	result += new TraceRecord("interfaceToOperationCompartment", "Interface", classifier, "BasicCompartment", compartment);
	result += compartment.oclAsType(notation::BasicCompartment).map traceRecordExtended_basicCompartment();
}



mapping trace::TraceRecord::traceRecordDiagram() : List(trace::TraceRecord)
when {self.mappingOperation.name = "diagramToDiagram"}
{
	var notationDiagram := self.getSelf().modelElement.oclAsType(notation::Diagram);
	var componentDiagram := self.getResult().modelElement;
	
	result += new TraceRecord("diagramToDiagram", "ComponentDiagram", componentDiagram, "Diagram", notationDiagram.toEObject());
	result += new TraceRecord("diagramToStringValueStyle", "ComponentDiagram", componentDiagram, "StringValueStyle", notationDiagram.styles->any(oclIsKindOf(notation::StringValueStyle)).eobject());
	result += new TraceRecord("diagramToDiagramStyle", "ComponentDiagram", componentDiagram, "DiagramStyle", notationDiagram.styles->any(oclIsKindOf(notation::DiagramStyle)).eobject());
	result += new TraceRecord("diagramToDiagramStylePapyrus", "ComponentDiagram", componentDiagram, "PapyrusDiagramStyle", notationDiagram.styles->any(oclIsKindOf(style::PapyrusDiagramStyle)).eobject());
}
/**
mapping trace::TraceRecord::traceRecordComponent() : List(trace::TraceRecord)
when {self.mappingOperation.name = "nodeToComponent"}
{
	var component := self.getSelf().modelElement.oclAsType(notation::Node);
	var component1 := self.getResult().modelElement;
	//result += new TraceRecord("nodeToComponent123", "Component", component1, "Diagram", component.toEObject());
	//result += new TraceRecord("diagramToDiagram", "ComponentDiagram", componentDiagram, "Diagram", notationDiagram.toEObject());
	//result += new TraceRecord("diagramToStringValueStyle", "ComponentDiagram", componentDiagram, "StringValueStyle", notationDiagram.styles->any(oclIsKindOf(notation::StringValueStyle)).eobject());
	//result += new TraceRecord("diagramToDiagramStyle", "ComponentDiagram", componentDiagram, "DiagramStyle", notationDiagram.styles->any(oclIsKindOf(notation::DiagramStyle)).eobject());
	//result += new TraceRecord("diagramToDiagramStylePapyrus", "ComponentDiagram", componentDiagram, "PapyrusDiagramStyle", notationDiagram.styles->any(oclIsKindOf(style::PapyrusDiagramStyle)).eobject());
}
**/



query trace::TraceRecord::getSelfNode() : notation::Node {
	assert error (self.getSelf().modelElement.oclIsKindOf(notation::Node)) with log('The contained model element is not a node.');
	return self.getSelf().modelElement.oclAsType(notation::Node);
}
/**
query getAllClassifiers() : OrderedSet(cmp::Classifier)
{
	return textualModel.rootObjects()[cmp::ComponentDiagram]->any(true).getAllTransitiveClassifiers();
}**/

query trace::TraceRecord::hasCommentLinkForAssociation() : Boolean
{
	var edge := self.getSelf().modelElement.oclAsType(notation::Connector);
	return self.mappingOperation.name = "edgeToCommentLink" and edge.isCommentLinkForAssociation();
}

query notation::Edge::isCommentLinkForAssociation() : Boolean
{
	var referencedElements := self.source.element.oclAsSet()->union(self.target.element.oclAsSet());
	return referencedElements->exists(oclIsKindOf(uml::Association)) and referencedElements->exists(oclIsKindOf(uml::Comment));
}

query notation::Node::getChild(type : String) : notation::Node
{
	return self.getChildInternal(type).oclAsType(notation::Node);
}

query notation::Edge::getChild(type : String) : notation::Node
{
	return self.getChildInternal(type).oclAsType(notation::Node);
}

query notation::View::getChild(type : String) : notation::View
{
	return self.getChildInternal(type);
}

query notation::View::getChildInternal(type : String) : notation::View
{
	var matches := self.children->select(v | v.type = type or v.type = type + "_CCN" );
	assert error (matches->size() = 1) with log('The child has to be identifiable unambigously by its type id ' + type, self);
	return matches->any(true);
}

query notation::Node::getChildren(type : String) : notation::Node
{
	return self.getChildInternalren(type).oclAsType(notation::Node);
}

query notation::Edge::getChildren(type : String) : notation::Node
{
	return self.getChildInternalren(type).oclAsType(notation::Node);
}

query notation::View::getChildren(type : String) : notation::View
{
	return self.getChildInternalren(type);
}

query notation::View::getChildInternalren(type : String) : notation::View
{
	var matches := self.children->any(v | v.type = type or v.type = type + "_CCN" );
	return matches->any(true);
}