import TransformationUtils_Component;

transformation Graphical_to_Textual_for_Component(in graphical : NOTATION, inout textual : TXT, in umlmodel : UML, in umlprimitives : UML);

modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype TXT uses cmp('http://www.cooperateproject.de/modeling/textual/component/Component');
modeltype TXTCMN uses textualCommons('http://www.cooperateproject.de/modeling/textual/commons');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
	var diagrams := graphical.rootObjects()[notation::Diagram]->select(type="PapyrusUMLComponentDiagram");
	assert fatal (diagrams->size() = 1);

	diagrams->map diagramToDiagram();
}

mapping notation::Diagram::diagramToDiagram() : cmp::ComponentDiagram
{
	title := self.name;
	rootpackage := self.map diagramToRootPackage();		
}

mapping notation::Diagram::diagramToRootPackage() : cmp::RootPackage
{
	//var relevantEdges := self.findRelevantEdges();
	referencedElement := self.element.oclAsType(uml::Package);
	//TODO
	//classifiers += self.children->select(type = PAPYRUS_NOTATION_SHAPE_COMPONENT_REGULAR).map nodeToComponent();
	//classifiers += self.children->select(type = PAPYRUS_NOTATION_SHAPE_INTERFACE_REGULAR).map nodeToInterface();
	classifiers += self.children->select(type = PAPYRUS_NOTATION_SHAPE_COMPONENT_REGULAR or type = PAPYRUS_NOTATION_SHAPE_INTERFACE_REGULAR).map nodeToClassifier();
	//interfaceRelations := self.edges.map edgeToInterfaceRelation();
	//relations := self.edges.map edgeToClassifierRelation(); //einbinden und fixen
	
}

mapping notation::Node::nodeToClassifier() : cmp::Classifier
disjuncts
	notation::Node::nodeToComponent,
	notation::Node::nodeToInterface
{
	//referencedElement := self.element.toElement();
	//comments := self.getCommentShape().map commentToComment();
}

mapping notation::Node::nodeToComponent() : cmp::Component
	when {		self.element.oclIsKindOf(uml::Component)	}{
	referencedElement :=self.element.oclAsType(uml::Component);
	var packagedElementsNode := self.children;
	
	interfaceRelation += self.diagram.edges->select(not isCommentLinkForAssociation())->select(source = self)->map edgeToInterfaceRelation();
	nestedInterface += packagedElementsNode.children->select(type = PAPYRUS_NOTATION_SHAPE_INTERFACE_REGULAR).map nodeToInterface();
	component += packagedElementsNode.children->select(type = PAPYRUS_NOTATION_SHAPE_COMPONENT_INPACKAGE).map nodeToComponent();

}


mapping notation::Node::nodeToInterface() : cmp::Interface
	when {		self.element.oclIsKindOf(uml::Interface)	}{
	referencedElement :=self.element.oclAsType(uml::Interface);
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Property)))-> map nodeToProperty();
	members += self.children->collect(children->select(element.oclIsKindOf(uml::Operation)))->map nodeToOperation();
}

mapping notation::Edge::edgeToClassifierRelation() : cmp::ClassifierRelation
disjuncts
 notation::Edge::edgeToGeneralization,
 notation::Edge::edgeToAbstraction,
 notation::Edge::edgeToManifestation,
 notation::Edge::edgeToSubstitution,
 notation::Edge::edgeToDependency
{
	
}


mapping notation::Edge::edgeToGeneralization() : cmp::Generalization
{
	
}
mapping notation::Edge::edgeToAbstraction() : cmp::Abstraction
{
	
}
mapping notation::Edge::edgeToManifestation() : cmp::Manifestation
{
	
}
mapping notation::Edge::edgeToSubstitution() : cmp::Substitution
{
	
}
mapping notation::Edge::edgeToDependency() : cmp::Dependency
{
	
}

mapping notation::Node::nodeToOperation() : cmp::Method {
	var operation := self.element.oclAsType(uml::Operation);
	referencedElement := operation;
	parameters += operation.ownedParameter->map umlParameterToParameter();
}

mapping uml::Parameter::umlParameterToParameter() : cmp::Parameter {
	referencedElement := self;
}

mapping notation::Node::nodeToProperty() : cmp::Attribute {
	var prop := self.element.oclAsType(uml::Property);
	referencedElement := prop;
}

mapping notation::View::commentToComment() : textualCommons::Comment
when {not self.oclIsInvalid() and not self.oclIsUndefined()}
{
	referencedElement := self.element.oclAsType(uml::Comment);
}

query notation::Diagram::findRelevantEdges() : OrderedSet(notation::Edge)
{
	return self.findRelevantEdgesByContainment();
}

//try2


mapping notation::Edge::edgeToInterfaceRelation() : cmp::InterfaceRelation
disjuncts
	notation::Edge::edgeToProvide,
	notation::Edge::edgeToRequire
{}

mapping notation::Edge::edgeToProvide() : cmp::Provide
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::InterfaceRealization) 
	}
{

	var realization := self.element.oclAsType(uml::InterfaceRealization);
	assert error (realization.source->size() = 1 and realization.target->size() = 1) with log ('Interfac realizations: Log must of exactly one source and one target.', realization);
	referencedElement := realization;
}
mapping notation::Edge::edgeToRequire() : cmp::Require
	when {
		self.element != null and
		self.element.oclIsKindOf(uml::Usage)
	}
{
	var usage := self.element.oclAsType(uml::Usage);
	assert error (usage.source->size() = 1 and usage.target->size() = 1) with log ('Interface usages: Log must of exactly one source and one target.', usage);
	referencedElement := usage;
}

query notation::Edge::isCommentLinkForAssociation() : Boolean {
	return self.isCommentLink() and (self.source.element.oclAsSet()->union(self.target.element.oclAsSet())->exists(oclIsKindOf(uml::Association)));
}
query notation::Edge::isCommentLink() : Boolean {
	return  (
				self.source.element.oclIsKindOf(uml::Comment) and
				self.target.element.oclIsKindOf(uml::Classifier)
			)
			or
			(
				self.source.element.oclIsKindOf(uml::Classifier) and
				self.target.element.oclIsKindOf(uml::Comment)
			)
}

query notation::Node::findRelevantEdges() : OrderedSet(notation::Edge)
{
	return self.findRelevantEdgesByContainment();
}

query notation::View::findRelevantEdgesByContainment() : OrderedSet(notation::Edge)
{
	assert fatal (self.element.oclIsKindOf(uml::Package)) with log('Finding relevant edges is only possible for views that represent packages.');
	var umlPackage = self.element.oclAsType(uml::Package);
	return self.diagram.edges->select(findOwningPackage() = umlPackage);
} 

query notation::Edge::findOwningPackage() : uml::Package
{ 
	return if self.oclIsKindOf(notation::Connector) then self.oclAsType(notation::Connector).findOwningPackage() else null endif;
}

mapping notation::View::commentViewToComment() : textualCommons::Comment
{
	var umlComment = self.element.oclAsType(uml::Comment);
	referencedElement := umlComment;
}

query notation::View::getCommentShape() : notation::View
{
	return self.diagram.children->select(type = PAPYRUS_NOTATION_SHAPE_COMMENT_REGULAR)->any(element.oclAsType(uml::Comment).annotatedElement->includes(self.element));
}
