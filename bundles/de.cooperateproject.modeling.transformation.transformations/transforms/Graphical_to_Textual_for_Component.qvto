import TransformationUtils_Component;

transformation Graphical_to_Textual_for_Component(in graphical : NOTATION, inout textual : TXT, in umlmodel : UML, in umlprimitives : UML);

modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype TXT uses cmp('http://www.cooperateproject.de/modeling/textual/component/Component');
modeltype TXTCMN uses textualCommons('http://www.cooperateproject.de/modeling/textual/commons');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
	var diagrams := graphical.rootObjects()[notation::Diagram]->select(type="PapyrusUMLComponentDiagram");
	assert fatal (diagrams->size() = 1);

	diagrams->map diagramToDiagram();
}

mapping notation::Diagram::diagramToDiagram() : cmp::ComponentDiagram
{
	title := self.name;
	rootpackage := self.map diagramToRootPackage();
}

mapping notation::Diagram::diagramToRootPackage() : cmp::RootPackage
{
	var relevantEdges := self.findRelevantEdges();
	referencedElement := self.element.oclAsType(uml::Package);
	//TODO
	classifiers := self.children->select(type = PAPYRUS_NOTATION_SHAPE_COMPONENT_REGULAR).map nodeToComponent();
	classifiers := self.children->select(type = PAPYRUS_NOTATION_SHAPE_INTERFACE_REGULAR).map nodeToInterface();
	relations := self.edges.map edgeToClassifierRelation();
}

mapping notation::Node::nodeToClassifier() : cmp::Classifier
disjuncts
	notation::Node::nodeToComponent,
	notation::Node::nodeToInterface
{
	//referencedElement := self.element.toElement();
	//comments := self.getCommentShape().map commentToComment();
}

mapping notation::Node::nodeToComponent() : cmp::Component
{
	referencedElement :=self.element.oclAsType(uml::Component);
	//TODO Port Comment Interface portRelation interfaceRelation component
}

mapping notation::Node::nodeToInterface() : cmp::Interface
{
	
}

mapping notation::Edge::edgeToClassifierRelation() : cmp::ClassifierRelation
disjuncts
 notation::Edge::edgeToGeneralization,
 notation::Edge::edgeToAbstraction,
 notation::Edge::edgeToManifestation,
 notation::Edge::edgeToSubstitution,
 notation::Edge::edgeToDependency
{
	
}

mapping notation::Edge::edgeToGeneralization() : cmp::Generalization
{
	
}
mapping notation::Edge::edgeToAbstraction() : cmp::Abstraction
{
	
}
mapping notation::Edge::edgeToManifestation() : cmp::Manifestation
{
	
}
mapping notation::Edge::edgeToSubstitution() : cmp::Substitution
{
	
}
mapping notation::Edge::edgeToDependency() : cmp::Dependency
{
	
}

mapping notation::View::commentToComment() : textualCommons::Comment
when {not self.oclIsInvalid() and not self.oclIsUndefined()}
{
	referencedElement := self.element.oclAsType(uml::Comment);
}

query notation::Diagram::findRelevantEdges() : OrderedSet(notation::Edge)
{
	return self.findRelevantEdgesByContainment();
}

query notation::Node::findRelevantEdges() : OrderedSet(notation::Edge)
{
	return self.findRelevantEdgesByContainment();
}

query notation::View::findRelevantEdgesByContainment() : OrderedSet(notation::Edge)
{
	assert fatal (self.element.oclIsKindOf(uml::Package)) with log('Finding relevant edges is only possible for views that represent packages.');
	var umlPackage = self.element.oclAsType(uml::Package);

	return self.diagram.edges->select(findOwningPackage() = umlPackage);
} 

query notation::Edge::findOwningPackage() : uml::Package
{
	return if self.oclIsKindOf(notation::Connector) then self.oclAsType(notation::Connector).findOwningPackage() else null endif;
}

mapping notation::View::commentViewToComment() : textualCommons::Comment
{
	var umlComment = self.element.oclAsType(uml::Comment);
	referencedElement := umlComment;
}

query notation::View::getCommentShape() : notation::View
{
	return self.diagram.children->select(type = PAPYRUS_NOTATION_SHAPE_COMMENT_REGULAR)->any(element.oclAsType(uml::Comment).annotatedElement->includes(self.element));
}
