/*
 * generated by Xtext
 */
package de.cooperateproject.modeling.textual.cls.validation

import de.cooperateproject.modeling.textual.cls.cls.Association
import de.cooperateproject.modeling.textual.cls.cls.Attribute
import de.cooperateproject.modeling.textual.cls.cls.Class
import de.cooperateproject.modeling.textual.cls.cls.Classifier
import de.cooperateproject.modeling.textual.cls.cls.ClsPackage
import de.cooperateproject.modeling.textual.cls.cls.Commentable
import de.cooperateproject.modeling.textual.cls.cls.DataTypeReference
import de.cooperateproject.modeling.textual.cls.cls.Generalization
import de.cooperateproject.modeling.textual.cls.cls.Implementation
import de.cooperateproject.modeling.textual.cls.cls.Interface
import de.cooperateproject.modeling.textual.cls.cls.Method
import de.cooperateproject.modeling.textual.cls.cls.Package
import de.cooperateproject.modeling.textual.cls.cls.PackageImport
import de.cooperateproject.modeling.textual.cls.cls.Property
import de.cooperateproject.modeling.textual.cls.cls.TypeReference
import de.cooperateproject.modeling.textual.cls.cls.UMLTypeReference
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.uml2.uml.Operation
import org.eclipse.uml2.uml.Type
import org.eclipse.uml2.uml.TypedElement
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.validation.Check
import org.eclipse.uml2.uml.Model
import org.eclipse.emf.ecore.EStructuralFeature

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ClsValidator extends AbstractClsValidator {

	@Check
	def checkAliasExpression(Classifier classifier) {
		val model = classifier.referencedElement.model
		val refNode = classifier.extractRefNode(ClsPackage.eINSTANCE.namedElementAliased_AliasExpression)

		if (model != null && refNode != null) {
			val modelAlias = classifier.referencedElement.nameExpression
			val aliasString = refNode.text ?: "aliasString"
			val textModelAlias = classifier.alias
			if (modelAlias == null) {
				if (checkIfNameExists(aliasString, model)) {
					aliasExistError(aliasString)
				} else {
					error("No alias '" + aliasString + "' found",
						ClsPackage.eINSTANCE.namedElementAliased_AliasExpression, ClsValidatorIssueId.NO_ALIAS_NAME, {
							aliasString
						})
				}
			} else if (modelAlias.name != textModelAlias) {
				if (checkIfNameExists(aliasString, model)) {
					aliasExistError(aliasString)
				} else {
					error("Inconsistent alias '" + aliasString + "' found",
						ClsPackage.eINSTANCE.namedElementAliased_AliasExpression, ClsValidatorIssueId.WRONG_ALIAS_NAME, {
							aliasString
						})
				}
			}
		}

	}

	private def aliasExistError(String alias) {
		error('''Alias: «alias» already exists!''', ClsPackage.eINSTANCE.namedElementAliased_AliasExpression,
			ClsValidatorIssueId.ALIAS_EXISTS, {
				alias
			})
	}

	private static def boolean checkIfNameExists(String name, Model model) {
		var elements = model.ownedMembers
		for (element : elements) {
			if (element.name.equals(name)) {
				return true;
			}
			var alias = element.nameExpression
			if (alias != null && alias.name.equals(name)) {
				return true;
			}
		}
		return false;
	}

	@Check
	def checkIfAssociationExists(Association association) {
		if (association.referencedElement?.model == null && association.nearestPackage?.referencedElement?.model != null) {
			val refNode = association.extractRefNode(ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement)
			val propertyNameLeft = association.properties?.extractRefNode(
				ClsPackage.eINSTANCE.associationProperties_PropertyLeft)?.text ?: ""
			val propertyNameRight = association.properties?.extractRefNode(
				ClsPackage.eINSTANCE.associationProperties_PropertyRight)?.text ?: ""
			val associationName = refNode.text ?: "associationName"
			val String[] issueData = #[associationName, propertyNameLeft, propertyNameRight]
			error("No Referenced UML-Association Element", ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement,
				ClsValidatorIssueId.NO_ASSOCIATION_REFERENCE, issueData)
		}
	}

	@Check
	def checkIfGeneralizationExists(Generalization generalization) {
		if (generalization.referencedElement?.model == null && generalization.nearestPackage?.referencedElement?.model != null) {
			error("No Referenced UML-Generalization Element", ClsPackage.eINSTANCE.generalization_ReferencedElement,
				ClsValidatorIssueId.NO_GENERALIZATION_REFERENCE)
		}
	}

	@Check
	def checkIfRealizationExists(Implementation realization) {
		if (realization.referencedElement?.model == null && realization.nearestPackage?.referencedElement?.model != null) {
			error("No Referenced UML-InterfaceRealization Element",
				ClsPackage.eINSTANCE.implementation_ReferencedElement, ClsValidatorIssueId.NO_REALIZATION_REFERENCE)
		}
	}

	@Check
	def checkIfClassExists(Class classifier) {
		var eClass = classifier.eGet(ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement);
		
		if (eClass instanceof org.eclipse.uml2.uml.Class) {
			checkIfClassifierExists(classifier, "className", "Couldn't find UML-Class '", ClsValidatorIssueId.NO_CLASS_REFERENCE)
		} else {
			wrongClassifierType(classifier.name, " is not a class", ClsValidatorIssueId.NOT_A_CLASS)
		}
	}

	@Check
	def checkIfInterfaceExists(Interface classifier) {
		var eInterface = classifier.eGet(ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement)
		
		if (eInterface instanceof org.eclipse.uml2.uml.Interface) {
			checkIfClassifierExists(classifier, "interfaceName", "Couldn't find UML-Interface '", ClsValidatorIssueId.NO_INTERFACE_REFERENCE)
		} else {
			wrongClassifierType(classifier.name, " is not an interface", ClsValidatorIssueId.NOT_AN_INTERFACE)
		}
	}

	private def checkIfClassifierExists(Classifier classifier, String defaultName, String errorMsg, ClsValidatorIssueId errorType) {
		if (classifier.referencedElement?.model == null && classifier.nearestPackage?.referencedElement?.model != null) {
			val refNode = classifier.extractRefNode(ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement)
			val classifierName = refNode.text ?: defaultName
			error(errorMsg + classifierName + "' in model",
				ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement, errorType, {
					classifierName
				})
		}
	}

	private def wrongClassifierType(String classifier, String errorMsg, ClsValidatorIssueId errorType) {
		error(classifier + errorMsg, ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement, errorType, {
			classifier
		})
	}

	@Check
	def checkIfPackageExists(Package pack) {
		if (pack.referencedElement?.model == null && pack.owningPackage?.referencedElement?.model != null) {
			val refNode = pack.extractRefNode(ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement)
			val packageName = refNode.text ?: "packageName"
			error("Couldn't find UML-Package '" + packageName + "' in model",
				ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement, ClsValidatorIssueId.NO_PACKAGE_REFERENCE, {
					packageName
				})
		}
	}

	@Check
	def checkIfPackageImportExists(PackageImport imported) {
		if (imported.referencedElement?.model == null && imported.importingNamespace?.referencedElement?.model != null) {
			val refNode = imported.extractRefNode(ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement)
			val packageName = refNode.text ?: "packageName"
			error("Couldn't find  PackageImport for '" + packageName + "' in model",
				ClsPackage.eINSTANCE.packageImport_ReferencedElement, ClsValidatorIssueId.NO_IMPORT_REFERENCE, {
					packageName
				})
		}
	}

	@Check
	def checkIfPropertyExists(Attribute attribute) {
		if (attribute.referencedElement?.model == null && attribute.owner?.referencedElement?.model != null) {
			val refNode = attribute.extractRefNode(ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement)
			val attributeName = refNode.text ?: "attributeName"
			error("No Referenced UML-Property", ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement,
				ClsValidatorIssueId.NO_PROPERTY_REFERENCE, {
					attributeName
				})
		}
	}

	@Check
	def checkCorrectPropertyType(Property<? extends NamedElement> property) {
		val model = property.referencedElement.model
		val refNode = property.extractRefNode(ClsPackage.eINSTANCE.property_Type)
		val typeName = refNode.text ?: "typeName"

		if (model != null && !property.hasCorrectType) {
			error("Inconsistent Type detected", ClsPackage.eINSTANCE.property_Type, ClsValidatorIssueId.WRONG_PROPERTY_TYPE, {
				typeName
			})
		}
	}

	@Check
	def checkIfOperationExists(Method method) {
		if (method.referencedElement?.model == null && method.owner?.referencedElement?.model != null) {
			error("No Referenced UML-Operation", ClsPackage.eINSTANCE.UMLReferencingElement_ReferencedElement,
				ClsValidatorIssueId.NO_OPERATION_REFERENCE)
		}
	}

	@Check
	def checkIfCommentExists(Commentable commentable) {
		if (commentable.comment.model == null && commentable.comment.owner != null) {
			error("No Referenced UML-Comment", ClsPackage.eINSTANCE.commentable_Comment, ClsValidatorIssueId.NO_COMMENT_REFERENCE)
		}
	}
	
	private def error(String message, EStructuralFeature feature, ClsValidatorIssueId code, String... issueData) {
		error(message, feature, code.ID, issueData);
	}

	private static def extractRefNode(EObject element, EReference ref) {
		NodeModelUtils.findNodesForFeature(element, ref).head
	}

	private static def hasCorrectType(Property<? extends NamedElement> property) {
		val umlReferencedElement = property.referencedElement
		var Type umlType = null
		if (umlReferencedElement instanceof TypedElement) {
			umlType = umlReferencedElement.type
		} else if (umlReferencedElement instanceof Operation) {
			umlType = umlReferencedElement.type
		}
		return property.type.matches(umlType)
	}

	private static def matches(TypeReference clsType, Type umlType) {
		if (clsType instanceof DataTypeReference) {
			var type = clsType.type
			var refType = TypeConverter.getPrimitive(umlType)
			return type.equals(refType)
		} else if (clsType instanceof UMLTypeReference) {
			var type = clsType.type
			return type.name.equals(umlType.name)
		} else if (clsType == null) {
			return umlType == null
		}
		return true
	}

}
