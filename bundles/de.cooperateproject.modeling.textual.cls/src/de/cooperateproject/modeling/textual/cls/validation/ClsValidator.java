/*
 * generated by Xtext 2.10.0
 */
package de.cooperateproject.modeling.textual.cls.validation;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.Switch;
import org.eclipse.uml2.uml.Element;
import org.eclipse.xtext.validation.Check;

import de.cooperateproject.modeling.textual.cls.cls.AssociationMemberEnd;
import de.cooperateproject.modeling.textual.cls.cls.Attribute;
import de.cooperateproject.modeling.textual.cls.cls.Class;
import de.cooperateproject.modeling.textual.cls.cls.Method;
import de.cooperateproject.modeling.textual.cls.cls.util.ClsSwitch;
import de.cooperateproject.modeling.textual.cls.issues.ClsAssociationMemberEndRoleName;
import de.cooperateproject.modeling.textual.cls.issues.ClsCardinalityCheck;
import de.cooperateproject.modeling.textual.cls.issues.ClsPropertyAbstractQualifier;
import de.cooperateproject.modeling.textual.cls.issues.ClsPropertyStaticQualifier;
import de.cooperateproject.modeling.textual.cls.issues.ClsUMLReferencingElementMissingElement;
import de.cooperateproject.modeling.textual.common.metamodel.textualCommons.NamedElement;
import de.cooperateproject.modeling.textual.common.metamodel.textualCommons.TextualCommonsPackage;
import de.cooperateproject.modeling.textual.common.metamodel.textualCommons.UMLReferencingElement;

/**
 * Cls-validator for the editor.
 */
public class ClsValidator extends AbstractClsValidator {

    private static final Switch<EStructuralFeature> MISSING_REFERENCE_FEATURE_SWITCH = new UMLReferencingElementFeatureSwitch();

    @Check
    private void checkUMLMissingReferencedElement(UMLReferencingElement<Element> referencingElement) {
        if (ClsUMLReferencingElementMissingElement.hasIssue(referencingElement)) {
            info("The element is not available in UML. It will be created when saving.",
                    MISSING_REFERENCE_FEATURE_SWITCH.doSwitch(referencingElement),
                    ClsUMLReferencingElementMissingElement.MISSING_UML_REFERENCE);
        }
    }

    @Check
    private void checkAssociationRoleNames(AssociationMemberEnd memberEnd) {
        if (ClsAssociationMemberEndRoleName.hasIssues(memberEnd)) {
            info("The used role name is different to the previously used one. "
                    + "The previously used one will be updated when saving.",
                    TextualCommonsPackage.Literals.NAMED_ELEMENT__NAME, ClsAssociationMemberEndRoleName.ISSUE_CODE);
        }
    }

    @Check
    private void checkCorrectPropertyQualifier(Class property) {
        if (ClsPropertyAbstractQualifier.hasIssues(property)) {
            info("Wrong abstract Qualifier. The old one will be overwritten.",
                    TextualCommonsPackage.Literals.NAMED_ELEMENT__NAME, ClsPropertyAbstractQualifier.ISSUE_CODE);
        }
    }

    @Check
    private void checkCorrectPropertyQualifier(Method property) {
        if (ClsPropertyAbstractQualifier.hasIssues(property)) {
            info("Wrong abstract Qualifier. The old one will be overwritten.",
                    TextualCommonsPackage.Literals.NAMED_ELEMENT__NAME, ClsPropertyAbstractQualifier.ISSUE_CODE);
        }

        if (ClsPropertyStaticQualifier.hasIssues(property)) {
            info("Wrong static Qualifier. The old one will be overwritten.",
                    TextualCommonsPackage.Literals.NAMED_ELEMENT__NAME, ClsPropertyStaticQualifier.ISSUE_CODE);
        }
    }

    @Check
    private void checkCorrectPropertyQualifier(Attribute property) {
        if (ClsPropertyStaticQualifier.hasIssues(property)) {
            info("Wrong static Qualifier. The old one will be overwritten.",
                    TextualCommonsPackage.Literals.NAMED_ELEMENT__NAME, ClsPropertyStaticQualifier.ISSUE_CODE);
        }
    }

    @Check
    private void checkCardinality(AssociationMemberEnd memberEnd) {
        if (ClsCardinalityCheck.hasIssues(memberEnd)) {
            info("Wrong cardinality. The old one will be overwritten.",
                    TextualCommonsPackage.Literals.NAMED_ELEMENT__NAME, ClsCardinalityCheck.ISSUE_CODE);
        }
    }

    private void info(String message, EStructuralFeature feature, String code) {
        info(message, feature, code, new String[0]);
    }

    private static class UMLReferencingElementFeatureSwitch extends ClsSwitch<EStructuralFeature> {

        @Override
        public EStructuralFeature caseNamedElement(NamedElement object) {
            return TextualCommonsPackage.Literals.NAMED_ELEMENT__NAME;
        }

        @Override
        public EStructuralFeature defaultCase(EObject object) {
            return TextualCommonsPackage.Literals.UML_REFERENCING_ELEMENT__REFERENCED_ELEMENT;
        }

    }

}
