/*
 * generated by Xtext
 */
package de.cooperateproject.modeling.textual.cls.serializer;

import com.google.inject.Inject;
import de.cooperateproject.modeling.textual.cls.cls.Association;
import de.cooperateproject.modeling.textual.cls.cls.AssociationEnd;
import de.cooperateproject.modeling.textual.cls.cls.Attribute;
import de.cooperateproject.modeling.textual.cls.cls.ClassDef;
import de.cooperateproject.modeling.textual.cls.cls.ClassDiagram;
import de.cooperateproject.modeling.textual.cls.cls.ClassName;
import de.cooperateproject.modeling.textual.cls.cls.ClassType;
import de.cooperateproject.modeling.textual.cls.cls.ClsPackage;
import de.cooperateproject.modeling.textual.cls.cls.Comment;
import de.cooperateproject.modeling.textual.cls.cls.CommentLink;
import de.cooperateproject.modeling.textual.cls.cls.ConnectorCardinalitiy;
import de.cooperateproject.modeling.textual.cls.cls.ConnectorLabel;
import de.cooperateproject.modeling.textual.cls.cls.DataType;
import de.cooperateproject.modeling.textual.cls.cls.Generalization;
import de.cooperateproject.modeling.textual.cls.cls.Implementation;
import de.cooperateproject.modeling.textual.cls.cls.Methode;
import de.cooperateproject.modeling.textual.cls.services.ClsGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ClsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ClsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ClsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ClsPackage.ASSOCIATION:
				sequence_Association(context, (Association) semanticObject); 
				return; 
			case ClsPackage.ASSOCIATION_END:
				sequence_AssociationEnd(context, (AssociationEnd) semanticObject); 
				return; 
			case ClsPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ClsPackage.CLASS:
				sequence_Class(context, (de.cooperateproject.modeling.textual.cls.cls.Class) semanticObject); 
				return; 
			case ClsPackage.CLASS_DEF:
				sequence_ClassDef(context, (ClassDef) semanticObject); 
				return; 
			case ClsPackage.CLASS_DIAGRAM:
				sequence_ClassDiagram(context, (ClassDiagram) semanticObject); 
				return; 
			case ClsPackage.CLASS_NAME:
				sequence_Name(context, (ClassName) semanticObject); 
				return; 
			case ClsPackage.CLASS_TYPE:
				sequence_ClassType(context, (ClassType) semanticObject); 
				return; 
			case ClsPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case ClsPackage.COMMENT_LINK:
				sequence_CommentLink(context, (CommentLink) semanticObject); 
				return; 
			case ClsPackage.CONNECTOR_CARDINALITIY:
				sequence_ConnectorCardinalitiy(context, (ConnectorCardinalitiy) semanticObject); 
				return; 
			case ClsPackage.CONNECTOR_LABEL:
				sequence_ConnectorLabel(context, (ConnectorLabel) semanticObject); 
				return; 
			case ClsPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case ClsPackage.GENERALIZATION:
				sequence_Generalization(context, (Generalization) semanticObject); 
				return; 
			case ClsPackage.IMPLEMENTATION:
				sequence_Implementation(context, (Implementation) semanticObject); 
				return; 
			case ClsPackage.METHODE:
				sequence_Methode(context, (Methode) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AssociationEnd returns AssociationEnd
	 *
	 * Constraint:
	 *     type=[ClassName|ID]
	 */
	protected void sequence_AssociationEnd(ISerializationContext context, AssociationEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.ASSOCIATION_END__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.ASSOCIATION_END__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getAssociationEndAccess().getTypeClassNameIDTerminalRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassElement returns Association
	 *     Connector returns Association
	 *     Association returns Association
	 *
	 * Constraint:
	 *     (left=AssociationEnd right=AssociationEnd cardinality=ConnectorCardinalitiy? comment=Comment?)
	 */
	protected void sequence_Association(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (visibility=Visibility? static?='static'? final?='final'? name=ID type=Type)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassElement returns ClassDef
	 *     ClassDef returns ClassDef
	 *
	 * Constraint:
	 *     (classes+=ClassName classes+=ClassName*)
	 */
	protected void sequence_ClassDef(ISerializationContext context, ClassDef semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDiagram returns ClassDiagram
	 *
	 * Constraint:
	 *     elements+=ClassElement*
	 */
	protected void sequence_ClassDiagram(ISerializationContext context, ClassDiagram semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ClassType
	 *     ClassType returns ClassType
	 *
	 * Constraint:
	 *     type=[ClassName|ID]
	 */
	protected void sequence_ClassType(ISerializationContext context, ClassType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.CLASS_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.CLASS_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getClassTypeAccess().getTypeClassNameIDTerminalRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassElement returns Class
	 *     Class returns Class
	 *
	 * Constraint:
	 *     (abstract?='abstract'? name=[ClassName|ID] members+=Member*)
	 */
	protected void sequence_Class(ISerializationContext context, de.cooperateproject.modeling.textual.cls.cls.Class semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassElement returns CommentLink
	 *     Connector returns CommentLink
	 *     CommentLink returns CommentLink
	 *
	 * Constraint:
	 *     (left=AssociationEnd comment=Comment)
	 */
	protected void sequence_CommentLink(ISerializationContext context, CommentLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.CONNECTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.CONNECTOR__LEFT));
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.COMMENT_LINK__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.COMMENT_LINK__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getCommentLinkAccess().getLeftAssociationEndParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCommentLinkAccess().getCommentCommentParserRuleCall_2_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     comment=STRING
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getCommentSTRINGTerminalRuleCall_2_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorCardinalitiy returns ConnectorCardinalitiy
	 *
	 * Constraint:
	 *     (left=Cardinality? right=Cardinality? label=ConnectorLabel? (direction='<' | direction='>')?)
	 */
	protected void sequence_ConnectorCardinalitiy(ISerializationContext context, ConnectorCardinalitiy semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConnectorLabel returns ConnectorLabel
	 *
	 * Constraint:
	 *     (label=ID | label=STRING)
	 */
	protected void sequence_ConnectorLabel(ISerializationContext context, ConnectorLabel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     type=DataTypeEnum
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypeDataTypeEnumEnumRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassElement returns Generalization
	 *     Connector returns Generalization
	 *     Generalization returns Generalization
	 *
	 * Constraint:
	 *     (left=AssociationEnd right=AssociationEnd)
	 */
	protected void sequence_Generalization(ISerializationContext context, Generalization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.CONNECTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.CONNECTOR__LEFT));
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.GENERALIZATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.GENERALIZATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getGeneralizationAccess().getLeftAssociationEndParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGeneralizationAccess().getRightAssociationEndParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassElement returns Implementation
	 *     Connector returns Implementation
	 *     Implementation returns Implementation
	 *
	 * Constraint:
	 *     (left=AssociationEnd right=AssociationEnd)
	 */
	protected void sequence_Implementation(ISerializationContext context, Implementation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.CONNECTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.CONNECTOR__LEFT));
			if (transientValues.isValueTransient((EObject) semanticObject, ClsPackage.Literals.IMPLEMENTATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ClsPackage.Literals.IMPLEMENTATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getImplementationAccess().getLeftAssociationEndParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImplementationAccess().getRightAssociationEndParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Methode
	 *     Methode returns Methode
	 *
	 * Constraint:
	 *     (
	 *         visibility=Visibility? 
	 *         abstract?='abstract'? 
	 *         static?='static'? 
	 *         final?='final'? 
	 *         name=ID 
	 *         (attributes+=Attribute attributes+=Attribute*)* 
	 *         type=Type?
	 *     )
	 */
	protected void sequence_Methode(ISerializationContext context, Methode semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassName returns ClassName
	 *     Name returns ClassName
	 *
	 * Constraint:
	 *     (name=ID | ((longname=STRING | longname=ID) name=ID))
	 */
	protected void sequence_Name(ISerializationContext context, ClassName semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
}
