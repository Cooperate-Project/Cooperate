/*
 * generated by Xtext 2.9.0
 */
package de.cooperateproject.modeling.language.usecase.serializer;

import com.google.inject.Inject;
import de.cooperateproject.modeling.language.usecase.services.UseCaseGrammarAccess;
import de.cooperateproject.modeling.language.usecase.usecase.Actor;
import de.cooperateproject.modeling.language.usecase.usecase.Association;
import de.cooperateproject.modeling.language.usecase.usecase.Constraint;
import de.cooperateproject.modeling.language.usecase.usecase.Diagram;
import de.cooperateproject.modeling.language.usecase.usecase.Extension;
import de.cooperateproject.modeling.language.usecase.usecase.ExtensionPoint;
import de.cooperateproject.modeling.language.usecase.usecase.Include;
import de.cooperateproject.modeling.language.usecase.usecase.Multiplicity;
import de.cooperateproject.modeling.language.usecase.usecase.Test;
import de.cooperateproject.modeling.language.usecase.usecase.Test2;
import de.cooperateproject.modeling.language.usecase.usecase.UMLModelReference;
import de.cooperateproject.modeling.language.usecase.usecase.UseCase;
import de.cooperateproject.modeling.language.usecase.usecase.UsecasePackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class UseCaseSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UseCaseGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UsecasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UsecasePackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case UsecasePackage.ASSOCIATION:
				sequence_Association(context, (Association) semanticObject); 
				return; 
			case UsecasePackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case UsecasePackage.DIAGRAM:
				sequence_Diagram(context, (Diagram) semanticObject); 
				return; 
			case UsecasePackage.EXTENSION:
				sequence_Extension(context, (Extension) semanticObject); 
				return; 
			case UsecasePackage.EXTENSION_POINT:
				sequence_ExtensionPoint(context, (ExtensionPoint) semanticObject); 
				return; 
			case UsecasePackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case UsecasePackage.MULTIPLICITY:
				sequence_Multiplicity(context, (Multiplicity) semanticObject); 
				return; 
			case UsecasePackage.SYSTEM:
				sequence_System(context, (de.cooperateproject.modeling.language.usecase.usecase.System) semanticObject); 
				return; 
			case UsecasePackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case UsecasePackage.TEST2:
				sequence_Test2(context, (Test2) semanticObject); 
				return; 
			case UsecasePackage.UML_MODEL_REFERENCE:
				sequence_UMLModelReference(context, (UMLModelReference) semanticObject); 
				return; 
			case UsecasePackage.USE_CASE:
				sequence_UseCase(context, (UseCase) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Commentable returns Actor
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (comments+=Comment* visibility=Visibility? modifiers+=Modifier* name=Name baseActors+=[Actor|Name]?)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Commentable returns Association
	 *     Association returns Association
	 *
	 * Constraint:
	 *     (
	 *         comments+=Comment* 
	 *         visibility=Visibility? 
	 *         modifiers+=Modifier* 
	 *         name=Name? 
	 *         baseAssociations+=[Association|Name]? 
	 *         actorMultiplicity=Multiplicity? 
	 *         actor=[Actor|Name] 
	 *         usecaseMultiplicity=Multiplicity? 
	 *         usecase=[UseCase|Name] 
	 *         ownedRules+=Constraint*
	 *     )
	 */
	protected void sequence_Association(ISerializationContext context, Association semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (language=ExpressionType expression=STRING)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UsecasePackage.Literals.CONSTRAINT__LANGUAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UsecasePackage.Literals.CONSTRAINT__LANGUAGE));
			if (transientValues.isValueTransient(semanticObject, UsecasePackage.Literals.CONSTRAINT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UsecasePackage.Literals.CONSTRAINT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getLanguageExpressionTypeParserRuleCall_0_0(), semanticObject.getLanguage());
		feeder.accept(grammarAccess.getConstraintAccess().getExpressionSTRINGTerminalRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Diagram returns Diagram
	 *
	 * Constraint:
	 *     (
	 *         umlModel=UMLModelReference 
	 *         test=Test 
	 *         test2=Test2 
	 *         actors+=Actor* 
	 *         system=System 
	 *         associations+=Association*
	 *     )
	 */
	protected void sequence_Diagram(ISerializationContext context, Diagram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Commentable returns ExtensionPoint
	 *     ExtensionPoint returns ExtensionPoint
	 *
	 * Constraint:
	 *     (comments+=Comment* visibility=Visibility? modifiers+=Modifier* name=Name)
	 */
	protected void sequence_ExtensionPoint(ISerializationContext context, ExtensionPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Commentable returns Extension
	 *     Extension returns Extension
	 *
	 * Constraint:
	 *     (comments+=Comment* visibility=Visibility? name=Name? location=[ExtensionPoint|Name] condition=Constraint?)
	 */
	protected void sequence_Extension(ISerializationContext context, Extension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Commentable returns Include
	 *     Include returns Include
	 *
	 * Constraint:
	 *     (comments+=Comment* visibility=Visibility? name=Name? addition=[UseCase|Name])
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns Multiplicity
	 *
	 * Constraint:
	 *     (lowerBound=MultiplicityElement upperBound=MultiplicityElement?)
	 */
	protected void sequence_Multiplicity(ISerializationContext context, Multiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Commentable returns System
	 *     System returns System
	 *
	 * Constraint:
	 *     (comments+=Comment* name=Name usecases+=UseCase*)
	 */
	protected void sequence_System(ISerializationContext context, de.cooperateproject.modeling.language.usecase.usecase.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Test2 returns Test2
	 *
	 * Constraint:
	 *     actor=[Actor|FQN]
	 */
	protected void sequence_Test2(ISerializationContext context, Test2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UsecasePackage.Literals.TEST2__ACTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UsecasePackage.Literals.TEST2__ACTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTest2Access().getActorActorFQNParserRuleCall_1_0_1(), semanticObject.getActor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Test returns Test
	 *
	 * Constraint:
	 *     actor=[Actor|Name]
	 */
	protected void sequence_Test(ISerializationContext context, Test semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UsecasePackage.Literals.TEST__ACTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UsecasePackage.Literals.TEST__ACTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestAccess().getActorActorNameParserRuleCall_1_0_1(), semanticObject.getActor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UMLModelReference returns UMLModelReference
	 *
	 * Constraint:
	 *     importURI=ImportURI
	 */
	protected void sequence_UMLModelReference(ISerializationContext context, UMLModelReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UsecasePackage.Literals.UML_MODEL_REFERENCE__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UsecasePackage.Literals.UML_MODEL_REFERENCE__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUMLModelReferenceAccess().getImportURIImportURIParserRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Commentable returns UseCase
	 *     UseCase returns UseCase
	 *
	 * Constraint:
	 *     (comments+=Comment* name=Name baseUseCases+=[UseCase|Name]? (extensionPoints+=ExtensionPoint | extensions+=Extension | includes+=Include)*)
	 */
	protected void sequence_UseCase(ISerializationContext context, UseCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
