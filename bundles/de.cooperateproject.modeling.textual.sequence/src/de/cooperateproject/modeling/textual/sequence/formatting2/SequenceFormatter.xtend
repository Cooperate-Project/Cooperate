/*
 * generated by Xtext 2.11.0
 */
package de.cooperateproject.modeling.textual.sequence.formatting2;

import com.google.inject.Inject;
import de.cooperateproject.modeling.textual.sequence.sequence.Actor;
import de.cooperateproject.modeling.textual.sequence.sequence.Alternative;
import de.cooperateproject.modeling.textual.sequence.sequence.BehaviorFragment;
import de.cooperateproject.modeling.textual.sequence.sequence.BehaviorFragments;
import de.cooperateproject.modeling.textual.sequence.sequence.BehaviorFragmentsWithCondition;
import de.cooperateproject.modeling.textual.sequence.sequence.Critical;
import de.cooperateproject.modeling.textual.sequence.sequence.InnerTimeConstraint;
import de.cooperateproject.modeling.textual.sequence.sequence.Loop;
import de.cooperateproject.modeling.textual.sequence.sequence.Message;
import de.cooperateproject.modeling.textual.sequence.sequence.Option;
import de.cooperateproject.modeling.textual.sequence.sequence.Parallel;
import de.cooperateproject.modeling.textual.sequence.sequence.RootPackage;
import de.cooperateproject.modeling.textual.sequence.sequence.SequenceDiagram;
import de.cooperateproject.modeling.textual.sequence.sequence.TimeConstraint;
import de.cooperateproject.modeling.textual.sequence.services.SequenceGrammarAccess;
import org.eclipse.xtext.formatting2.AbstractFormatter2;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import de.cooperateproject.modeling.textual.sequence.sequence.SequencePackage

class SequenceFormatter extends AbstractFormatter2 {
	
	@Inject extension SequenceGrammarAccess

	def dispatch void format(SequenceDiagram sequencediagram, extension IFormattableDocument document) {
	    sequencediagram.regionFor.feature(SequencePackage.Literals.SEQUENCE_DIAGRAM__TITLE).append[newLines = 2]
		format(sequencediagram.getRootPackage(), document);
		for (Actor actors : sequencediagram.getActors()) {
            format(actors, document)
            actors.append[newLine]
        }
        sequencediagram.actors.last?.append[newLines = 2; priority=2]
        
        for (BehaviorFragment behaviorFragments : sequencediagram.getBehaviorFragments()) {
            format(behaviorFragments, document);
            behaviorFragments.append[newLine]
        }
		sequencediagram.regionFor.keyword(sequenceDiagramAccess.endSeqdKeyword_6).prepend[newLines = 2]
	}

	def dispatch void format(RootPackage rootpackage, extension IFormattableDocument document) {
	    rootpackage.regionFor.assignment(rootPackageAccess.nameAssignment_1).append[newLines = 2]
	}

	def dispatch void format(BehaviorFragments behaviorfragments, extension IFormattableDocument document) {
	    interior(
            behaviorfragments.regionFor.keyword(behaviorFragmentsAccess.leftCurlyBracketKeyword_0_0).append[newLine],
            behaviorfragments.regionFor.keyword(behaviorFragmentsAccess.rightCurlyBracketKeyword_0_2),
            [indent]
        )
		for (BehaviorFragment fragments : behaviorfragments.getFragments()) {
			format(fragments, document);
			fragments.append[newLine]
		}
	}

	def dispatch void format(Message message, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		format(message.getTimeConstraint(), document);
	}

	def dispatch void format(TimeConstraint timeconstraint, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (InnerTimeConstraint constraints : timeconstraint.getConstraints()) {
			format(constraints, document);
		}
	}

	def dispatch void format(Alternative alternative, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (BehaviorFragmentsWithCondition alternatives : alternative.getAlternatives()) {
			format(alternatives, document);
		}
	}

	def dispatch void format(Option option, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (BehaviorFragmentsWithCondition optional : option.getOptional()) {
			format(optional, document);
		}
	}

	def dispatch void format(Parallel parallel, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (BehaviorFragments parallels : parallel.getParallels()) {
			format(parallels, document);
		}
	}

	def dispatch void format(Critical critical, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (BehaviorFragment fragments : critical.getFragments()) {
			format(fragments, document);
		}
	}

	def dispatch void format(Loop loop, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (BehaviorFragment fragments : loop.getFragments()) {
			format(fragments, document);
		}
	}

	def dispatch void format(BehaviorFragmentsWithCondition behaviorfragmentswithcondition, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (BehaviorFragment fragments : behaviorfragmentswithcondition.getFragments()) {
			format(fragments, document);
		}
	}
}
