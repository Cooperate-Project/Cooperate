grammar de.cooperateproject.modeling.textual.sequence.Sequence with org.eclipse.xtext.common.Terminals

import "platform:/resource/de.cooperateproject.modeling.textual.sequence.metamodel/model/Sequence.ecore"
import "platform:/resource/de.cooperateproject.modeling.textual.common.metamodel/model/textualCommons.ecore" as commons
import "platform:/plugin/org.eclipse.uml2.uml/model/UML.ecore" as uml
import "http://www.eclipse.org/emf/2002/Ecore" as ecore



SequenceDiagram:
    {SequenceDiagram}
    '@start-seqd' title=STRING
    rootPackage=RootPackage
    actors += Actor* 
    fragments += Fragment*
    fragments += (Constraint | Observation)*
    '@end-seqd'
;

RootPackage:
    'rootElement' name = FQN
;

Actor:
    (deferred?='def')? 'act'  
        ((name = ID (typeMapping=ActorClassifierMapping)?)
        | (typeMapping=ActorClassifierMapping 'as' alias = ID)
        | (name = STRING (typeMapping=ActorClassifierMapping)? 'as' alias = ID))
    ('role['actorType=ActorType']')? comments+=InlineComment? 
;

ActorClassifierMapping:
    ':' ((classifier= [uml::Classifier|FQN]))
;


Fragment: 
    Message | OccurenceSpecification | CombinedFragment | Reference
;


OneFragment returns OrderedFragmentContainer:
    fragments += Fragment
;

OneOrMultipleFragments returns OrderedFragmentContainer:
    fragments += Fragment+
;



Condition:
    '['condition=UnescapedString']'
;

OrderedFragmentContainerNoCondition returns OrderedFragmentContainer:
    (('{' OneOrMultipleFragments'}' ('as' alias=ID)) | OneFragment)
;

OrderedFragmentContainerWithCondition returns OrderedFragmentContainer:
    condition=Condition (('{' fragments += Fragment+'}' ('as' alias=ID)?) | fragments += Fragment)
;

OrderedFragmentContainerWithConditionMandatoryBrackets returns OrderedFragmentContainer:
    condition=Condition '{' fragments += Fragment+'}'
;

OrderedFragmentContainerNoConditionMandatoryBrackets returns OrderedFragmentContainer:
    '{' fragments += Fragment+'}'
;

Message:
    (StandardMessage    |
        ResponseMessage | 
        FoundMessage    |
        LostMessage     |
        CreateMessage   |
        DestructionMessage)
       
    
;

ExplicitArrivalOccurenceReference: 
    'arrives''['explicitOccurenceSpecification=[ExplicitArrivalOccurenceSpecification]']'
;


ExplicitArrivalOccurenceSpecification: 
    'arrival' name=ID
;


StandardMessage:
    type=MessageType name=UnescapedString '('left = [Actor|FQN]',' right = [Actor|FQN]')' ('as' alias = ID)? sendEvent=ImplicitSendOccurenceSpecification
    (arrivalEvent=ExplicitArrivalOccurenceReference | arrivalEvent=ImplicitArrivalOccurenceSpecification)
;

ResponseMessage:
   'reply' name=UnescapedString '('(left = [Actor|FQN]|'_')',' (right = ([Actor|FQN])|'_')')' ('as' alias = ID)? sendEvent=ImplicitSendOccurenceSpecification
    (arrivalEvent=ExplicitArrivalOccurenceReference | arrivalEvent=ImplicitArrivalOccurenceSpecification)
;

FoundMessage returns StandardMessage:
    'found' type=MessageType name=UnescapedString '(''_'',' right = [Actor|FQN]')' ('as' alias = ID)? 
    (arrivalEvent=ImplicitArrivalOccurenceSpecification)
;

LostMessage returns Message:
    'lost' (('reply' {ResponseMessage}) | ({StandardMessage} type=MessageType)) name=UnescapedString '('left = [Actor|FQN]',' '_'')'
    ('as' alias = ID)? sendEvent=ImplicitSendOccurenceSpecification
;

CreateMessage:
    'create' name=UnescapedString? '('left = [Actor|FQN]',' right = [Actor|FQN]')' ('as' alias = ID)? 
    sendEvent=ImplicitSendOccurenceSpecification
    (arrivalEvent=ExplicitArrivalOccurenceReference | arrivalEvent=ImplicitArrivalOccurenceSpecification)
;

DestructionMessage:
    'dest' name=UnescapedString? '(' left = [Actor|FQN] ',' right = [Actor|FQN] ')' ('as' alias = ID)? 
    sendEvent=ImplicitSendOccurenceSpecification
    (arrivalEvent=ExplicitArrivalOccurenceReference | arrivalEvent=ImplicitArrivalOccurenceSpecification)
;


OccurenceSpecification:
    DestructionOccurenceSpecification | ExplicitArrivalOccurenceSpecification
;

DestructionOccurenceSpecification: 
    'dest' target=[Actor|FQN]
;

CombinedFragment:
    MultipleRegionContainer | SingleRegionContainer ('as' alias=ID)?   
;

SingleRegionContainer:
    Loop | Option | Critical
;


MultipleRegionContainer:
    Parallel | Alternative
;

Parallel:
    'par' '{' regions += OrderedFragmentContainerNoCondition+ '}'
;
Alternative:
    'alt' '{' regions += OrderedFragmentContainerWithCondition+ '}'
;

Loop:
    'loop' region = OrderedFragmentContainerWithConditionMandatoryBrackets
;

Option:
    'opt' region=OrderedFragmentContainerWithConditionMandatoryBrackets
;

Critical:
    'critical' region=OrderedFragmentContainerNoConditionMandatoryBrackets
;

Reference:
    'ref' reference=[uml::Interaction|FQN] ('as' alias = ID)? 
;

Constraint:
    'cstr' (TimeConstraint | DurationConstraint)
;

TimeConstraint:
    '('event=PointInTimeSelector')' 't''['time=UnescapedString']' 
;

DurationConstraint:
    '('interval=TimeIntervalSelector')''d''['duration=UnescapedString']' 
;

Observation:
    'obs' (TimeObservation | DurationObservation)
;

TimeObservation:
    '('event=PointInTimeSelector')' 't''['time=UnescapedString']' 
;

DurationObservation:
    '('interval=TimeIntervalSelector')''d''['duration=UnescapedString']' 
;

PointInTimeSelector:
    pointInTime=[PointInTime|FQN]
;

TimeIntervalSelector: 
    BiPointInTimeTimeIntervalSelector | FragmentTimeIntervalSelector
;

BiPointInTimeTimeIntervalSelector: 
    start=PointInTimeSelector','end=PointInTimeSelector
;

FragmentTimeIntervalSelector: 
    nonInstantaneousFragment=[NonInstantaneousFragment|FQN]
;


ImplicitSendOccurenceSpecification returns ImplicitMessageOccurenceSpecification: 
    {ImplicitMessageOccurenceSpecification}
;

ImplicitArrivalOccurenceSpecification returns ImplicitMessageOccurenceSpecification: 
    {ImplicitMessageOccurenceSpecification}
;

FQN:
    ID ('.' ID)*
;

InlineComment returns commons::Comment:
    'note''['body = CommentBody']'
;

Comment returns commons::Comment:
    'note' body = CommentBody
;

CommentBody returns ecore::EString:
    STRING
;

UnescapedString returns ecore::EString:
    ID | STRING
;

enum MessageType:
    SYNC = "sync"
    | ASYNC = "async"
;

enum ActorType:
    HUMAN = 'human'
    | MACHINE = 'machine'
;
