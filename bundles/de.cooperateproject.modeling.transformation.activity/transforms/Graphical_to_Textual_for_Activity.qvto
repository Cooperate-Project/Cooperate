import TransformationUtils_Activity;

transformation Grahpical_to_Textual_for_Activity(in graphical : NOTATION, inout textual : TXT, in umlmodel : UML, in umlprimitives : UML);

modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype TXT uses act('http://www.cooperateproject.de/modeling/textual/activity/Activity');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype TXTCMN uses textualCommons('http://www.cooperateproject.de/modeling/textual/commons');

main() {
	var diagrams := graphical.rootObjects()[notation::Diagram]->select(type="PapyrusUMLActivityDiagram");
	assert fatal (diagrams->size() = 1);
	diagrams->map diagramToDiagram();
}

mapping notation::Diagram::diagramToDiagram() : act::ActivityDiagram {
	title := self.name;
	rootPackage := self.map diagramToRootPackage();
}

mapping notation::Diagram::diagramToRootPackage() : act::RootPackage {
	referencedElement := self.element.oclAsType(uml::Package);
	
	var activities := self.children->select(type = PAPYRUS_NOTATION_SHAPE_ACTIVITY);
	assert fatal (activities->size() = 1);
	
	activity := activities->first().map nodeToActivity();
}

mapping notation::Node::nodeToActivity(): act::Activity {
	referencedElement := self.element.oclAsType(uml::Activity);
	
	// Nodes are no direct childs of the activity
	nodes := self.children->select(type = PAPYRUS_NOTATION_COMPARTMENT_ACTIVITY_ACTIVITYNODE).children.map nodeToNode();
	
	// Swimlane support
	children := self.children->select(type = PAPYRUS_NOTATION_COMPARTMENT_ACTIVITY_ACTIVITYNODE).children
	->select(type = PAPYRUS_NOTATION_SHAPE_ACTIVITY_PARTITION).map partitionToSwimlane();
	
	// Edges are direct childs of the root package / diagram
	flows := self.diagram.edges.map edgeToEdge();
}

mapping notation::Node::nodeToNode() : act::Node
disjuncts notation::Node::nodeToInitialNode,
notation::Node::nodeToFinalNode,
notation::Node::nodeToActionNode,
notation::Node::nodeToDecisionNode,
notation::Node::nodeToMergeNode,
notation::Node::nodeToFlowFinalNode,
notation::Node::nodeToForkNode,
notation::Node::nodeToJoinNode;

mapping notation::Node::nodeToInitialNode(): act::InitialNode 
	when {self.element.oclIsKindOf(uml::InitialNode)} {
	
	referencedElement := self.element.oclAsType(uml::InitialNode)
}

mapping notation::Node::nodeToFinalNode(): act::FinalNode 
	when {self.element.oclIsKindOf(uml::ActivityFinalNode)} {
	
	referencedElement := self.element.oclAsType(uml::ActivityFinalNode)
}

mapping notation::Node::nodeToActionNode(): act::ActionNode 
	when {self.element.oclIsKindOf(uml::OpaqueAction)} {
	
	referencedElement := self.element.oclAsType(uml::OpaqueAction)
}

mapping notation::Node::nodeToDecisionNode(): act::DecisionNode
	when {self.element.oclIsKindOf(uml::DecisionNode)} {
	
	referencedElement := self.element.oclAsType(uml::DecisionNode)
}

mapping notation::Node::nodeToMergeNode(): act::MergeNode
	when {self.element.oclIsKindOf(uml::MergeNode)} {
	
	referencedElement := self.element.oclAsType(uml::MergeNode)
}

mapping notation::Node::nodeToFlowFinalNode(): act::FlowFinalNode
	when {self.element.oclIsKindOf(uml::FlowFinalNode)} {
	
	referencedElement := self.element.oclAsType(uml::FlowFinalNode)
}

mapping notation::Node::nodeToForkNode(): act::ForkNode
	when {self.element.oclIsKindOf(uml::ForkNode)} {
	
	referencedElement := self.element.oclAsType(uml::ForkNode)
}

mapping notation::Node::nodeToJoinNode(): act::JoinNode
	when {self.element.oclIsKindOf(uml::JoinNode)} {
	
	referencedElement := self.element.oclAsType(uml::JoinNode)
}

mapping notation::Edge::edgeToEdge(): act::Flow {
	referencedElement := self.element.oclAsType(uml::ControlFlow)
}

// Swimlane support

mapping notation::Node::partitionToSwimlane() : act::Swimlane {

	nodes := self.children->select(type = PAPYRUS_NOTATION_COMPARTMENT_ACTIVITY_PARTITION_ACTIVITYNODE).children.map nodeToNode();
	
	referencedElement := self.element.oclAsType(uml::ActivityPartition)
}