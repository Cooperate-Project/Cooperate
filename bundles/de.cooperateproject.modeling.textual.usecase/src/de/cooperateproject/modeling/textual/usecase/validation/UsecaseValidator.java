/*
 * generated by Xtext 2.11.0
 */
package de.cooperateproject.modeling.textual.usecase.validation;

import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;

import com.google.inject.Inject;

import de.cooperateproject.modeling.textual.common.metamodel.textualCommons.NamedElement;
import de.cooperateproject.modeling.textual.usecase.usecase.Actor;
import de.cooperateproject.modeling.textual.usecase.usecase.RootPackage;
import de.cooperateproject.modeling.textual.usecase.usecase.System;
import de.cooperateproject.modeling.textual.usecase.usecase.UseCase;
import de.cooperateproject.modeling.textual.usecase.usecase.UsecasePackage;
import de.cooperateproject.modeling.textual.xtext.runtime.issues.IIssueCodeRegistry;
import de.cooperateproject.modeling.textual.xtext.runtime.validator.ICooperateAutomatedValidator;

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class UsecaseValidator extends AbstractUsecaseValidator {

    private static final String NAME_TAKEN = "name_taken";

    private static final String WRONG_ABSTRACT_ACTOR_QUALIFIER = "wrong_actor_visibility";
    private static final String WRONG_ABSTRACT_USECASE_QUALIFIER = "wrong_usecase_visibility";

    @Inject
    @SuppressWarnings("unused")
    private ICooperateAutomatedValidator automatedValidator;

    @Inject
    @SuppressWarnings("unused")
    private IIssueCodeRegistry issueCodeRegistry;

    @Check
    private void checkUniqueActor(RootPackage rootPackage) {
        EList<Actor> actors = rootPackage.getActors();
        for (Actor actor : actors) {
            compareNamedElements(actors, actor, UsecasePackage.Literals.ROOT_PACKAGE__ACTORS, NAME_TAKEN);
        }
    }

    @Check
    private void checkUniqueUseCase(UseCase useCase) {
        EList<UseCase> useCases = useCase.getSystem().getUsecases();
        compareNamedElements(useCases, useCase, UsecasePackage.Literals.USE_CASE__SYSTEM, NAME_TAKEN);
    }

    @Check
    private void checkUniqueSystems(System system) {
        EList<System> systems = system.getPackage().getSystems();
        compareNamedElements(systems, system, UsecasePackage.Literals.SYSTEM__PACKAGE, NAME_TAKEN);
    }

    private void compareNamedElements(List<? extends NamedElement> elements, NamedElement comparableElement,
            EStructuralFeature feature, String code) {
        for (NamedElement element : elements) {
            if (element.equals(comparableElement)) {
                return;
            }
            if (element.getName().equals(comparableElement.getName())) {
                error("\"" + element.getName() + "\"" + " no duplicates!", feature, code);
            }

        }
    }

    @Check
    private void checkActorQualifier(Actor actor) {
        if (actor.isAbstract() != actor.getReferencedElement().isAbstract()) {
            error("\"" + actor.getName() + "\"" + " has the wrong abstract qualifier!",
                    UsecasePackage.Literals.ACTOR__ABSTRACT, WRONG_ABSTRACT_ACTOR_QUALIFIER);
        }
    }

    @Check
    private void checkUseCaseQualifier(UseCase useCase) {
        if (useCase.isAbstract() != useCase.getReferencedElement().isAbstract()) {
            error("\"" + useCase.getName() + "\"" + " has the wrong abstract qualifier!",
                    UsecasePackage.Literals.USE_CASE__ABSTRACT, WRONG_ABSTRACT_ACTOR_QUALIFIER);
        }
    }
}
